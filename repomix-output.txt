This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-04-21T13:17:47.974Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
/
  Users/
    jess/
      Desktop/
        personal git/
          mobbin/
            formobbin/
              components/
                annotation/
                  annotation-canvas.tsx
                  annotation-header.tsx
                  box-handles.tsx
                  label-editor.tsx
                control-panel/
                  control-panel-header.tsx
                  element-editor.tsx
                  element-list.tsx
                  panel-footer-actions.tsx
                  summary-panel.tsx
                ui/
                  badge.tsx
                  button.tsx
                  card.tsx
                  input.tsx
                  label.tsx
                  reveal-on-hover.tsx
                  scroll-area.tsx
                  select.tsx
                  separator.tsx
                  tabs.tsx
                  toast.tsx
                  tooltip.tsx
                upload/
                  batch-card/
                    batch-header.tsx
                    constants.ts
                    image-grid.tsx
                    index.tsx
                    performance-stats.tsx
                    performance-tooltip.tsx
                    status-badge.tsx
                    utils.ts
                  batch-display.tsx
                  batch-list.tsx
                  dropzone-area.tsx
                  image-card.tsx
                  selected-images-panel.tsx
                annotation-editor.tsx
                control-panel.tsx
                element-list-item.tsx
                upload-interface.tsx
              hooks/
                use-annotation-state.tsx
                use-batch-management.ts
                use-box-interaction.tsx
                use-image-scale.tsx
                use-mobile.tsx
              lib/
                constants.ts
                file-utils.ts
                image-processor.ts
                schema_v2.sql
                schema_v3.sql
                storage.ts
                supabase.ts
                utils.ts

================================================================
Repository Files
================================================================

================
File: /Users/jess/Desktop/personal git/mobbin/formobbin/components/annotation/annotation-canvas.tsx
================
import { useRef, useEffect, memo } from "react"
import React from "react"
import { LabelEditor } from "./label-editor"
import { BoxHandles } from "./box-handles"
import { BoundingBox } from "@/types/annotation"

interface ImageState {
  imageUrl: string
  scale: number
  imageRef: React.RefObject<HTMLImageElement>
  containerRef: React.RefObject<HTMLDivElement>
}

interface BoxControls {
  boundingBoxes: BoundingBox[]
  selectedBox: BoundingBox | null
  onSelect: (box: BoundingBox) => void
  onUpdate: (box: BoundingBox) => void
  onDelete: (id: number) => void
  onDeselect: () => void
}

interface LabelEditing {
    editingLabelId: number | null
    editingLabelText: string
    setEditingLabelId: (id: number | null) => void
    setEditingLabelText: (text: string) => void
    updateLabelAndFinishEditing: () => void
  }

interface InteractionHandlers {
  startDragging: (e: React.MouseEvent | React.TouchEvent, box: BoundingBox) => void
  startResizing: (e: React.MouseEvent | React.TouchEvent, box: BoundingBox, handle: string) => void
  dragState: {
    isDragging: boolean
    startX: number
    startY: number
    originalBox: BoundingBox | null
  }
  resizeState: {
    isResizing: boolean
    handle: string | null
    startX: number
    startY: number
    originalBox: BoundingBox | null
  }
}

// Memoized box component to prevent unnecessary re-renders
const Box = memo(({ 
  box, 
  isSelected, 
  onSelect, 
  startDragging, 
  startResizing,
  labelEditing
}: { 
  box: BoundingBox
  isSelected: boolean
  onSelect: (box: BoundingBox) => void
  startDragging: (e: React.MouseEvent | React.TouchEvent, box: BoundingBox) => void
  startResizing: (e: React.MouseEvent | React.TouchEvent, box: BoundingBox, handle: string) => void
  labelEditing: {
    editingLabelId: number | null
    editingLabelText: string
    setEditingLabelId: (id: number | null) => void
    setEditingLabelText: (text: string) => void
    updateLabelAndFinishEditing: () => void
  }
}) => {
  return (
    <div
      key={box.id}
      className={`absolute border-2 ${isSelected ? 'border-slate-700' : 'border-muted-foreground/50'} cursor-move border-dotted`}
      style={{
        left: `${box.x}px`,
        top: `${box.y}px`,
        width: `${box.width}px`,
        height: `${box.height}px`,
      }}
      onClick={(e) => {
        e.stopPropagation()
        onSelect(box)
      }}
      onMouseDown={(e) => startDragging(e, box)}
      onTouchStart={(e) => startDragging(e, box)}
    >
      <BoxHandles 
        box={box} 
        isSelected={isSelected} 
        startResizing={startResizing} 
      />
      <LabelEditor 
        box={box} 
        isSelected={isSelected}
        {...labelEditing}
      />
    </div>
  )
})

Box.displayName = 'Box'

interface AnnotationCanvasProps {
  imageState: ImageState
  boxControls: BoxControls
  labelEditing: LabelEditing
  interactionHandlers: InteractionHandlers
  isMobile: boolean
}

export function AnnotationCanvas({
  imageState,
  boxControls,
  labelEditing,
  interactionHandlers,
  isMobile
}: AnnotationCanvasProps) {
  const { imageUrl, scale, imageRef, containerRef } = imageState
  const { boundingBoxes, selectedBox, onSelect, onDeselect } = boxControls
  const { startDragging, startResizing } = interactionHandlers

  return (
    <div
      ref={containerRef}
      className="relative"
      style={{ transform: `scale(${scale})`, transformOrigin: 'top left' }}
    >
      <img
        ref={imageRef}
        src={imageUrl}
        alt="Annotation target"
        className="max-w-full h-auto"
        draggable={false}
      />
      {boundingBoxes.map((box) => (
        <Box
          key={box.id}
          box={box}
          isSelected={selectedBox?.id === box.id}
          onSelect={onSelect}
          startDragging={startDragging}
          startResizing={startResizing}
          labelEditing={labelEditing}
        />
      ))}
    </div>
  )
}

================
File: /Users/jess/Desktop/personal git/mobbin/formobbin/components/annotation/annotation-header.tsx
================
import { ArrowLeft, Save } from "lucide-react"
import { Button } from "@/components/ui/button"

interface AnnotationHeaderProps {
  imageName: string
  onBack: () => void
  onSave: () => void
}

export function AnnotationHeader({ imageName, onBack, onSave }: AnnotationHeaderProps) {
  return (
    <div className="bg-background p-4 border-b flex items-center justify-between">
      <Button variant="ghost" onClick={onBack}>
        <ArrowLeft className="mr-2 h-4 w-4" />
        <span className="hidden sm:inline">Back to Upload</span>
        <span className="sm:hidden">Back</span>
      </Button>
      <h2 className="text-xl font-medium truncate max-w-[150px] sm:max-w-none">{imageName}</h2>
      <Button onClick={onSave} className="hidden md:flex">
        <Save className="mr-2 h-4 w-4" />
        Save
      </Button>
    </div>
  )
}

================
File: /Users/jess/Desktop/personal git/mobbin/formobbin/components/annotation/box-handles.tsx
================
import React from "react"
import { BoundingBox } from "@/types/annotation"

interface BoxHandlesProps {
  box: BoundingBox
  isSelected: boolean
  startResizing: (e: React.MouseEvent | React.TouchEvent, box: BoundingBox, handle: string) => void
}

export function BoxHandles({ box, isSelected, startResizing }: BoxHandlesProps) {
  if (!isSelected) return null

  const handleSize = 8
  const handleStyle = {
    width: handleSize,
    height: handleSize,
    backgroundColor: "white",
    border: "2px solid #3b82f6",
    position: "absolute" as const,
    borderRadius: "50%",
    cursor: "pointer",
  }

  const handles = [
    { position: "top-left", x: -handleSize / 2, y: -handleSize / 2, cursor: "nw-resize" },
    { position: "top-right", x: box.width - handleSize / 2, y: -handleSize / 2, cursor: "ne-resize" },
    { position: "bottom-left", x: -handleSize / 2, y: box.height - handleSize / 2, cursor: "sw-resize" },
    { position: "bottom-right", x: box.width - handleSize / 2, y: box.height - handleSize / 2, cursor: "se-resize" },
    { position: "top", x: box.width / 2 - handleSize / 2, y: -handleSize / 2, cursor: "n-resize" },
    { position: "right", x: box.width - handleSize / 2, y: box.height / 2 - handleSize / 2, cursor: "e-resize" },
    { position: "bottom", x: box.width / 2 - handleSize / 2, y: box.height - handleSize / 2, cursor: "s-resize" },
    { position: "left", x: -handleSize / 2, y: box.height / 2 - handleSize / 2, cursor: "w-resize" },
  ]

  return (
    <>
      {handles.map(({ position, x, y, cursor }) => (
        <div
          key={position}
          style={{
            ...handleStyle,
            left: x,
            top: y,
            cursor,
          }}
          onMouseDown={(e) => startResizing(e, box, position)}
          onTouchStart={(e) => startResizing(e, box, position)}
        />
      ))}
    </>
  )
}

================
File: /Users/jess/Desktop/personal git/mobbin/formobbin/components/annotation/label-editor.tsx
================
import { useState, useEffect, useRef } from "react"
import { BoundingBox } from "@/types/annotation"

interface LabelEditorProps {
  box: BoundingBox
  isSelected: boolean
  editingLabelId: number | null
  editingLabelText: string
  setEditingLabelId: (id: number | null) => void
  setEditingLabelText: (text: string) => void
  updateLabelAndFinishEditing: () => void
}

export function LabelEditor({
  box,
  isSelected,
  editingLabelId,
  editingLabelText,
  setEditingLabelId,
  setEditingLabelText,
  updateLabelAndFinishEditing
}: LabelEditorProps) {
  const [isHovered, setIsHovered] = useState(false)
  const inputRef = useRef<HTMLInputElement>(null)
  const isEditing = editingLabelId === box.id

  // Focus input when editing starts
  useEffect(() => {
    if (isEditing && inputRef.current) {
      inputRef.current.focus()
    }
  }, [isEditing])

  const handleLabelClick = (e: React.MouseEvent) => {
    e.stopPropagation()
    if (!isEditing) {
      setEditingLabelId(box.id)
      setEditingLabelText(box.textLabel)
    }
  }

  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === "Enter") {
      updateLabelAndFinishEditing()
    } else if (e.key === "Escape") {
      setEditingLabelId(null)
    }
  }

  const labelStyles = "bg-black text-white text-xs px-1 py-0.5 rounded"

  return (
    <div
      className="absolute -top-6 left-0 min-w-[60px] max-w-full"
      onMouseEnter={() => setIsHovered(true)}
      onMouseLeave={() => setIsHovered(false)}
      onClick={handleLabelClick}
    >
      {isEditing ? (
        <input
          ref={inputRef}
          type="text"
          value={editingLabelText}
          onChange={(e) => setEditingLabelText(e.target.value)}
          onKeyDown={handleKeyDown}
          onBlur={updateLabelAndFinishEditing}
          className={`${labelStyles} w-full outline-none border border-white`}
          placeholder="Enter label..."
        />
      ) : (
        <span className={`${labelStyles} pointer-events-auto cursor-text inline-block max-w-[200px] overflow-hidden text-ellipsis whitespace-nowrap`}>
          {box.textLabel}
        </span>
      )}
    </div>
  )
}

================
File: /Users/jess/Desktop/personal git/mobbin/formobbin/components/control-panel/control-panel-header.tsx
================
import { Clock } from "lucide-react"

interface ControlPanelHeaderProps {
  title: string
  masterPromptRuntime: number
  totalInferenceTime: number
}

export function ControlPanelHeader({ 
  title, 
  masterPromptRuntime, 
  totalInferenceTime 
}: ControlPanelHeaderProps) {
  return (
    <div className="p-4 border-b">
      <h3 className="text-lg font-medium">{title}</h3>
      <div className="mt-2 space-y-2">
        <div className="flex items-center justify-between">
          <div className="flex items-center text-sm">
            <Clock className="h-4 w-4 mr-1.5 text-muted-foreground" />
            <span>Master Prompt Runtime:</span>
          </div>
          <span className="font-medium">{masterPromptRuntime.toFixed(1)}s</span>
        </div>
        <div className="flex items-center justify-between">
          <div className="flex items-center text-sm">
            <Clock className="h-4 w-4 mr-1.5 text-muted-foreground" />
            <span>Total Inference Time:</span>
          </div>
          <span className="font-medium">{totalInferenceTime.toFixed(1)}s</span>
        </div>
      </div>
    </div>
  )
}

================
File: /Users/jess/Desktop/personal git/mobbin/formobbin/components/control-panel/element-editor.tsx
================
import { ArrowLeft, List, WandSparkles, Trash2 } from "lucide-react"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { ScrollArea } from "@/components/ui/scroll-area"
import { BoundingBox } from "@/types/annotation"

interface ElementEditorProps {
  selectedBox: BoundingBox
  onBoxUpdate: (box: BoundingBox) => void
  onBoxDelete: (id: number) => void
  onBackToList: () => void
  editingLabelState: {
    editingLabelId: number | null
    editingLabelText: string
    setEditingLabelText: (text: string) => void
    updateLabelAndFinishEditing: () => void
  }
}

export function ElementEditor({
  selectedBox,
  onBoxUpdate,
  onBoxDelete,
  onBackToList,
  editingLabelState
}: ElementEditorProps) {
  const handleLabelChange = (value: string) => {
    onBoxUpdate({ ...selectedBox, label: value })
  }

  const handleDescriptionChange = (value: string) => {
    onBoxUpdate({ ...selectedBox, description: value })
  }

  const handleCoordinateChange = (field: keyof BoundingBox, value: string) => {
    const numValue = Number.parseInt(value, 10)
    if (!isNaN(numValue)) {
      onBoxUpdate({ ...selectedBox, [field]: numValue })
    }
  }

  return (
    <>
      <div className="p-4 border-b">
        <div className="flex items-center justify-between mb-2">
          <h3 className="text-lg font-medium">Edit Element</h3>
          <Button variant="ghost" size="sm" onClick={onBackToList}>
            <ArrowLeft className="h-4 w-4 mr-1" />
            {/* <List className="h-4 w-4 mr-1" /> */}
            Back to Element List
          </Button>
        </div>
        <p className="text-sm text-muted-foreground">
          {`Editing "${selectedBox.textLabel}" (${selectedBox.label})`}
        </p>
      </div>

      <ScrollArea className={"flex-1"}>
        <div className="p-4 space-y-4">
          <div className="space-y-2">
            <Label htmlFor="element-type">Element Type</Label>
            <Select value={selectedBox.label} onValueChange={handleLabelChange}>
              <SelectTrigger id="element-type">
                <SelectValue placeholder="Select element type" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="Button">Button</SelectItem>
                <SelectItem value="Tab Bar">Tab Bar</SelectItem>
                <SelectItem value="Text Field">Text Field</SelectItem>
                <SelectItem value="Checkbox">Checkbox</SelectItem>
                <SelectItem value="Dropdown">Dropdown</SelectItem>
                <SelectItem value="Image">Image</SelectItem>
                <SelectItem value="Icon">Icon</SelectItem>
                <SelectItem value="Label">Label</SelectItem>
              </SelectContent>
            </Select>
          </div>

          <div className="space-y-2">
            <Label htmlFor="text-label">Text Label</Label>
            {/* <Input
              id="text-label"
              value={editingLabelState.editingLabelText}
              onChange={(e) => editingLabelState.setEditingLabelText(e.target.value)}
              onBlur={editingLabelState.updateLabelAndFinishEditing}
              placeholder="Enter display text"
            /> */}
            <Input
              id="text-label"
              value={selectedBox.textLabel}
              readOnly
              disabled
              placeholder="Enter display text"
            />
          </div>

          <div className="space-y-2">
            <Label htmlFor="description">Description</Label>
            <Input
              id="description"
              value={selectedBox.description}
              onChange={(e) => handleDescriptionChange(e.target.value)}
              placeholder="Enter description"
            />
          </div>

          <div className="space-y-2">
            <Label htmlFor="inference-time">Inference Time</Label>
            <Input
              id="inference-time"
              value={`${selectedBox.inferenceTime.toFixed(2)}s`}
              readOnly
              disabled
              className="bg-muted"
            />
          </div>

          <div className="grid grid-cols-2 gap-2">
            <div className="space-y-2">
              <Label htmlFor="x-coord">X Position</Label>
              <Input
                id="x-coord"
                type="number"
                value={selectedBox.x}
                onChange={(e) => handleCoordinateChange("x", e.target.value)}
              />
            </div>
            <div className="space-y-2">
              <Label htmlFor="y-coord">Y Position</Label>
              <Input
                id="y-coord"
                type="number"
                value={selectedBox.y}
                onChange={(e) => handleCoordinateChange("y", e.target.value)}
              />
            </div>
            <div className="space-y-2">
              <Label htmlFor="width">Width</Label>
              <Input
                id="width"
                type="number"
                value={selectedBox.width}
                onChange={(e) => handleCoordinateChange("width", e.target.value)}
              />
            </div>
            <div className="space-y-2">
              <Label htmlFor="height">Height</Label>
              <Input
                id="height"
                type="number"
                value={selectedBox.height}
                onChange={(e) => handleCoordinateChange("height", e.target.value)}
              />
            </div>
          </div>
        </div>
      </ScrollArea>

      <div className="border-t p-4">
        {/* <Button className="w-full mb-3" variant="outline" onClick={() => onBoxDelete(selectedBox.id)}>
          <Trash2 className="mr-2 h-4 w-4" />
          Delete Element
        </Button> */}
        <Button className="w-full mb-3" variant="outline">
          <WandSparkles className="mr-2 h-4 w-4" />
          Regenerate Description and Label
        </Button>
        <Button className="w-full" onClick={onBackToList}>
          <ArrowLeft className="mr-2 h-4 w-4" />
          Back to Element List
        </Button>
      </div>
    </>
  )
}

================
File: /Users/jess/Desktop/personal git/mobbin/formobbin/components/control-panel/element-list.tsx
================
import { Trash2, Eye, Clock } from "lucide-react"
import { Button } from "@/components/ui/button"
import { ScrollArea } from "@/components/ui/scroll-area"
import { BoundingBox } from "@/types/annotation"
import { RevealOnHover } from "@/components/ui/reveal-on-hover"

interface ElementListProps {
  boundingBoxes: BoundingBox[]
  selectedBox: BoundingBox | null
  hoveredBoxId: number | null
  setHoveredBoxId: (id: number | null) => void
  onBoxSelect: (box: BoundingBox) => void
  onBoxDelete: (id: number) => void
  // isMobile: boolean
  // setActiveTab?: (tab: string) => void
}

export function ElementList({
  boundingBoxes,
  selectedBox,
  hoveredBoxId,
  setHoveredBoxId,
  onBoxSelect,
  onBoxDelete,
  // isMobile,
  // setActiveTab
}: ElementListProps) {
  const handleElementSelect = (box: BoundingBox) => {
    onBoxSelect(box)
    // if (isMobile && setActiveTab) {
    //   setActiveTab("editor")
    // }
  }

  const getBorderClass = (box: BoundingBox) => {
    // if (isMobile) {
    //   return selectedBox?.id === box.id ? "border-primary" : "border-border"
    // }
    return hoveredBoxId === box.id ? "border-primary/50" : "border-border"
  }

  const renderBoxDetails = (box: BoundingBox) => (
    <RevealOnHover isVisible={hoveredBoxId === box.id}>
      <div className="text-xs text-muted-foreground">{box.label}</div>
      <div className="text-xs text-muted-foreground mt-1">
        x: {box.x}, y: {box.y}, w: {box.width}, h: {box.height}
      </div>
      <div className="text-xs flex items-center mt-1 text-muted-foreground">
        <Clock className="h-3 w-3 mr-1" />
        Inference Time: {box.inferenceTime.toFixed(2)}s
      </div>
    </RevealOnHover>
  )

  const renderActionButtons = (box: BoundingBox) => (
    <div className="flex gap-1 ml-2">
      <Button
        variant="ghost"
        size="icon"
        className="h-7 w-7"
        onClick={(e) => {
          e.stopPropagation()
          handleElementSelect(box)
        }}
      >
        <Eye className="h-4 w-4" />
      </Button>
      <Button
        variant="ghost"
        size="icon"
        className="h-7 w-7 text-destructive"
        onClick={(e) => {
          e.stopPropagation()
          onBoxDelete(box.id)
        }}
      >
        <Trash2 className="h-4 w-4" />
      </Button>
    </div>
  )

  return (
    <ScrollArea className="flex-1">
      <div className="p-4 space-y-2">
        {boundingBoxes.map((box) => (
          <div
            key={box.id}
            className={`rounded-md border transition-all duration-200 overflow-hidden ${getBorderClass(box)}`}
            onMouseEnter={() => setHoveredBoxId(box.id)}
            onMouseLeave={() => setHoveredBoxId(null)}
            onClick={() => handleElementSelect(box)}
          >
            <div className="p-3">
              <div className="flex items-center justify-between">
                <div className="font-medium truncate">{box.textLabel}</div>
                {hoveredBoxId === box.id && renderActionButtons(box)}
              </div>

              {renderBoxDetails(box)}
            </div>
          </div>
        ))}
      </div>
    </ScrollArea>
  )
}

================
File: /Users/jess/Desktop/personal git/mobbin/formobbin/components/control-panel/panel-footer-actions.tsx
================
import { ArrowLeft, ArrowRight, Save, Download } from "lucide-react"
import { Button } from "@/components/ui/button"

interface PanelFooterActionsProps {
  onSave: () => void
  onExport: () => void
  onPreviousImage?: () => void
  onNextImage?: () => void
}

export function PanelFooterActions({
  onSave,
  onExport,
  onPreviousImage,
  onNextImage
}: PanelFooterActionsProps) {
  return (
    <div className="border-t p-4">
      <div className="grid grid-cols-2 gap-2 mb-3">
        <Button variant="outline" className="w-full" onClick={onPreviousImage} disabled={!onPreviousImage}>
          <ArrowLeft className="mr-2 h-4 w-4" />
          {onPreviousImage ? "Previous" : "Prev Image"}
        </Button>
        <Button variant="outline" className="w-full" onClick={onNextImage} disabled={!onNextImage}>
          {onNextImage ? "Next" : "Next Image"}
          <ArrowRight className="ml-2 h-4 w-4" />
        </Button>
      </div>
      <Button className="w-full mb-2" onClick={onSave}>
        <Save className="mr-2 h-4 w-4" />
        Save Changes
      </Button>
      <Button className="w-full" variant="secondary" onClick={onExport}>
        <Download className="mr-2 h-4 w-4" />
        Export Annotations
      </Button>
    </div>
  )
}

================
File: /Users/jess/Desktop/personal git/mobbin/formobbin/components/control-panel/summary-panel.tsx
================
import { Clock } from "lucide-react"
import { ScrollArea } from "@/components/ui/scroll-area"
import { Separator } from "@/components/ui/separator"

interface SummaryPanelProps {
  masterPromptRuntime: number
  totalInferenceTime: number
  elementCount: number
}

export function SummaryPanel({ masterPromptRuntime, totalInferenceTime, elementCount }: SummaryPanelProps) {
  const averageInferenceTime = elementCount > 0 ? totalInferenceTime / elementCount : 0

  return (
    <ScrollArea className="h-[calc(100vh-220px)]">
      <div className="p-4 space-y-4">
        <div className="space-y-2">
          <h3 className="text-lg font-medium">Performance Summary</h3>
          <div className="mt-2 space-y-2">
            <div className="flex items-center justify-between">
              <div className="flex items-center text-sm">
                <Clock className="h-4 w-4 mr-1.5 text-muted-foreground" />
                <span>Master Prompt Runtime:</span>
              </div>
              <span className="font-medium">{masterPromptRuntime.toFixed(1)}s</span>
            </div>
            <div className="flex items-center justify-between">
              <div className="flex items-center text-sm">
                <Clock className="h-4 w-4 mr-1.5 text-muted-foreground" />
                <span>Total Inference Time:</span>
              </div>
              <span className="font-medium">{totalInferenceTime.toFixed(1)}s</span>
            </div>
          </div>
        </div>

        <Separator />

        <div className="space-y-2">
          <h3 className="text-lg font-medium">Element Statistics</h3>
          <div className="text-sm">
            <p>Total Elements: {elementCount}</p>
            <p>Average Inference Time: {averageInferenceTime.toFixed(2)}s</p>
          </div>
        </div>
      </div>
    </ScrollArea>
  )
}

================
File: /Users/jess/Desktop/personal git/mobbin/formobbin/components/ui/badge.tsx
================
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const badgeVariants = cva(
  "inline-flex items-center justify-center rounded-md border px-2 py-0.5 text-xs font-medium w-fit whitespace-nowrap shrink-0 [&>svg]:size-3 gap-1 [&>svg]:pointer-events-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive transition-[color,box-shadow] overflow-hidden",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground [a&]:hover:bg-primary/90",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground [a&]:hover:bg-secondary/90",
        destructive:
          "border-transparent bg-destructive text-white [a&]:hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "text-foreground [a&]:hover:bg-accent [a&]:hover:text-accent-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

function Badge({
  className,
  variant,
  asChild = false,
  ...props
}: React.ComponentProps<"span"> &
  VariantProps<typeof badgeVariants> & { asChild?: boolean }) {
  const Comp = asChild ? Slot : "span"

  return (
    <Comp
      data-slot="badge"
      className={cn(badgeVariants({ variant }), className)}
      {...props}
    />
  )
}

export { Badge, badgeVariants }

================
File: /Users/jess/Desktop/personal git/mobbin/formobbin/components/ui/button.tsx
================
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow-xs hover:bg-primary/90",
        destructive:
          "bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
        secondary:
          "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80",
        ghost:
          "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

function Button({
  className,
  variant,
  size,
  asChild = false,
  ...props
}: React.ComponentProps<"button"> &
  VariantProps<typeof buttonVariants> & {
    asChild?: boolean
  }) {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      data-slot="button"
      className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    />
  )
}

export { Button, buttonVariants }

================
File: /Users/jess/Desktop/personal git/mobbin/formobbin/components/ui/card.tsx
================
import * as React from "react"

import { cn } from "@/lib/utils"

function Card({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card"
      className={cn(
        "bg-card text-card-foreground flex flex-col gap-6 rounded-xl border py-6 shadow-sm",
        className
      )}
      {...props}
    />
  )
}

function CardHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-header"
      className={cn(
        "@container/card-header grid auto-rows-min grid-rows-[auto_auto] items-start gap-1.5 px-6 has-data-[slot=card-action]:grid-cols-[1fr_auto] [.border-b]:pb-6",
        className
      )}
      {...props}
    />
  )
}

function CardTitle({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-title"
      className={cn("leading-none font-semibold", className)}
      {...props}
    />
  )
}

function CardDescription({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

function CardAction({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-action"
      className={cn(
        "col-start-2 row-span-2 row-start-1 self-start justify-self-end",
        className
      )}
      {...props}
    />
  )
}

function CardContent({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-content"
      className={cn("px-6", className)}
      {...props}
    />
  )
}

function CardFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-footer"
      className={cn("flex items-center px-6 [.border-t]:pt-6", className)}
      {...props}
    />
  )
}

export {
  Card,
  CardHeader,
  CardFooter,
  CardTitle,
  CardAction,
  CardDescription,
  CardContent,
}

================
File: /Users/jess/Desktop/personal git/mobbin/formobbin/components/ui/input.tsx
================
import * as React from "react"

import { cn } from "@/lib/utils"

function Input({ className, type, ...props }: React.ComponentProps<"input">) {
  return (
    <input
      type={type}
      data-slot="input"
      className={cn(
        "file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input flex h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]",
        "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
        className
      )}
      {...props}
    />
  )
}

export { Input }

================
File: /Users/jess/Desktop/personal git/mobbin/formobbin/components/ui/label.tsx
================
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"

import { cn } from "@/lib/utils"

function Label({
  className,
  ...props
}: React.ComponentProps<typeof LabelPrimitive.Root>) {
  return (
    <LabelPrimitive.Root
      data-slot="label"
      className={cn(
        "flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50",
        className
      )}
      {...props}
    />
  )
}

export { Label }

================
File: /Users/jess/Desktop/personal git/mobbin/formobbin/components/ui/reveal-on-hover.tsx
================
import React from "react"
import { cn } from "@/lib/utils"

interface RevealOnHoverProps {
  isVisible: boolean
  children: React.ReactNode
  className?: string
  duration?: string
  visibleHeight?: string
  visibleMargin?: string
}

export function RevealOnHover({
  isVisible,
  children,
  className,
  duration = "duration-200",
  visibleHeight = "max-h-20",
  visibleMargin = "mt-2",
}: RevealOnHoverProps) {
  return (
    <div
      className={cn(
        "overflow-hidden transition-all",
        duration,
        isVisible ? `${visibleHeight} ${visibleMargin} opacity-100` : "max-h-0 opacity-0",
        className
      )}
    >
      {children}
    </div>
  )
}

================
File: /Users/jess/Desktop/personal git/mobbin/formobbin/components/ui/scroll-area.tsx
================
"use client"

import * as React from "react"
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area"

import { cn } from "@/lib/utils"

function ScrollArea({
  className,
  children,
  ...props
}: React.ComponentProps<typeof ScrollAreaPrimitive.Root>) {
  return (
    <ScrollAreaPrimitive.Root
      data-slot="scroll-area"
      className={cn("relative", className)}
      {...props}
    >
      <ScrollAreaPrimitive.Viewport
        data-slot="scroll-area-viewport"
        className="focus-visible:ring-ring/50 size-full rounded-[inherit] transition-[color,box-shadow] outline-none focus-visible:ring-[3px] focus-visible:outline-1"
      >
        {children}
      </ScrollAreaPrimitive.Viewport>
      <ScrollBar />
      <ScrollAreaPrimitive.Corner />
    </ScrollAreaPrimitive.Root>
  )
}

function ScrollBar({
  className,
  orientation = "vertical",
  ...props
}: React.ComponentProps<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>) {
  return (
    <ScrollAreaPrimitive.ScrollAreaScrollbar
      data-slot="scroll-area-scrollbar"
      orientation={orientation}
      className={cn(
        "flex touch-none p-px transition-colors select-none",
        orientation === "vertical" &&
          "h-full w-2.5 border-l border-l-transparent",
        orientation === "horizontal" &&
          "h-2.5 flex-col border-t border-t-transparent",
        className
      )}
      {...props}
    >
      <ScrollAreaPrimitive.ScrollAreaThumb
        data-slot="scroll-area-thumb"
        className="bg-border relative flex-1 rounded-full"
      />
    </ScrollAreaPrimitive.ScrollAreaScrollbar>
  )
}

export { ScrollArea, ScrollBar }

================
File: /Users/jess/Desktop/personal git/mobbin/formobbin/components/ui/select.tsx
================
"use client"

import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { CheckIcon, ChevronDownIcon, ChevronUpIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Select({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Root>) {
  return <SelectPrimitive.Root data-slot="select" {...props} />
}

function SelectGroup({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Group>) {
  return <SelectPrimitive.Group data-slot="select-group" {...props} />
}

function SelectValue({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Value>) {
  return <SelectPrimitive.Value data-slot="select-value" {...props} />
}

function SelectTrigger({
  className,
  size = "default",
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Trigger> & {
  size?: "sm" | "default"
}) {
  return (
    <SelectPrimitive.Trigger
      data-slot="select-trigger"
      data-size={size}
      className={cn(
        "border-input data-[placeholder]:text-muted-foreground [&_svg:not([class*='text-'])]:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 dark:hover:bg-input/50 flex w-fit items-center justify-between gap-2 rounded-md border bg-transparent px-3 py-2 text-sm whitespace-nowrap shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 data-[size=default]:h-9 data-[size=sm]:h-8 *:data-[slot=select-value]:line-clamp-1 *:data-[slot=select-value]:flex *:data-[slot=select-value]:items-center *:data-[slot=select-value]:gap-2 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      {children}
      <SelectPrimitive.Icon asChild>
        <ChevronDownIcon className="size-4 opacity-50" />
      </SelectPrimitive.Icon>
    </SelectPrimitive.Trigger>
  )
}

function SelectContent({
  className,
  children,
  position = "popper",
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Content>) {
  return (
    <SelectPrimitive.Portal>
      <SelectPrimitive.Content
        data-slot="select-content"
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 relative z-50 max-h-(--radix-select-content-available-height) min-w-[8rem] origin-(--radix-select-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border shadow-md",
          position === "popper" &&
            "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
          className
        )}
        position={position}
        {...props}
      >
        <SelectScrollUpButton />
        <SelectPrimitive.Viewport
          className={cn(
            "p-1",
            position === "popper" &&
              "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)] scroll-my-1"
          )}
        >
          {children}
        </SelectPrimitive.Viewport>
        <SelectScrollDownButton />
      </SelectPrimitive.Content>
    </SelectPrimitive.Portal>
  )
}

function SelectLabel({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Label>) {
  return (
    <SelectPrimitive.Label
      data-slot="select-label"
      className={cn("text-muted-foreground px-2 py-1.5 text-xs", className)}
      {...props}
    />
  )
}

function SelectItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Item>) {
  return (
    <SelectPrimitive.Item
      data-slot="select-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex w-full cursor-default items-center gap-2 rounded-sm py-1.5 pr-8 pl-2 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4 *:[span]:last:flex *:[span]:last:items-center *:[span]:last:gap-2",
        className
      )}
      {...props}
    >
      <span className="absolute right-2 flex size-3.5 items-center justify-center">
        <SelectPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </SelectPrimitive.ItemIndicator>
      </span>
      <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
    </SelectPrimitive.Item>
  )
}

function SelectSeparator({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Separator>) {
  return (
    <SelectPrimitive.Separator
      data-slot="select-separator"
      className={cn("bg-border pointer-events-none -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function SelectScrollUpButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollUpButton>) {
  return (
    <SelectPrimitive.ScrollUpButton
      data-slot="select-scroll-up-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronUpIcon className="size-4" />
    </SelectPrimitive.ScrollUpButton>
  )
}

function SelectScrollDownButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollDownButton>) {
  return (
    <SelectPrimitive.ScrollDownButton
      data-slot="select-scroll-down-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronDownIcon className="size-4" />
    </SelectPrimitive.ScrollDownButton>
  )
}

export {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectLabel,
  SelectScrollDownButton,
  SelectScrollUpButton,
  SelectSeparator,
  SelectTrigger,
  SelectValue,
}

================
File: /Users/jess/Desktop/personal git/mobbin/formobbin/components/ui/separator.tsx
================
"use client"

import * as React from "react"
import * as SeparatorPrimitive from "@radix-ui/react-separator"

import { cn } from "@/lib/utils"

function Separator({
  className,
  orientation = "horizontal",
  decorative = true,
  ...props
}: React.ComponentProps<typeof SeparatorPrimitive.Root>) {
  return (
    <SeparatorPrimitive.Root
      data-slot="separator-root"
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "bg-border shrink-0 data-[orientation=horizontal]:h-px data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-px",
        className
      )}
      {...props}
    />
  )
}

export { Separator }

================
File: /Users/jess/Desktop/personal git/mobbin/formobbin/components/ui/tabs.tsx
================
"use client"

import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"

import { cn } from "@/lib/utils"

function Tabs({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Root>) {
  return (
    <TabsPrimitive.Root
      data-slot="tabs"
      className={cn("flex flex-col gap-2", className)}
      {...props}
    />
  )
}

function TabsList({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.List>) {
  return (
    <TabsPrimitive.List
      data-slot="tabs-list"
      className={cn(
        "bg-muted text-muted-foreground inline-flex h-9 w-fit items-center justify-center rounded-lg p-[3px]",
        className
      )}
      {...props}
    />
  )
}

function TabsTrigger({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Trigger>) {
  return (
    <TabsPrimitive.Trigger
      data-slot="tabs-trigger"
      className={cn(
        "data-[state=active]:bg-background dark:data-[state=active]:text-foreground focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:outline-ring dark:data-[state=active]:border-input dark:data-[state=active]:bg-input/30 text-foreground dark:text-muted-foreground inline-flex h-[calc(100%-1px)] flex-1 items-center justify-center gap-1.5 rounded-md border border-transparent px-2 py-1 text-sm font-medium whitespace-nowrap transition-[color,box-shadow] focus-visible:ring-[3px] focus-visible:outline-1 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:shadow-sm [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}

function TabsContent({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Content>) {
  return (
    <TabsPrimitive.Content
      data-slot="tabs-content"
      className={cn("flex-1 outline-none", className)}
      {...props}
    />
  )
}

export { Tabs, TabsList, TabsTrigger, TabsContent }

================
File: /Users/jess/Desktop/personal git/mobbin/formobbin/components/ui/toast.tsx
================
import * as React from "react"
import * as ToastPrimitives from "@radix-ui/react-toast"
import { cva, type VariantProps } from "class-variance-authority"
import { cn } from "@/lib/utils"

const ToastProvider = ToastPrimitives.Provider
const ToastViewport = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Viewport>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Viewport
    ref={ref}
    className={cn(
      "fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]",
      className
    )}
    {...props}
  />
))
ToastViewport.displayName = ToastPrimitives.Viewport.displayName

const toastVariants = cva(
  "group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full",
  {
    variants: {
      variant: {
        default: "border bg-background text-foreground",
        destructive:
          "destructive group border-destructive bg-destructive text-destructive-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

const Toast = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> &
    VariantProps<typeof toastVariants>
>(({ className, variant, ...props }, ref) => {
  return (
    <ToastPrimitives.Root
      ref={ref}
      className={cn(toastVariants({ variant }), className)}
      {...props}
    />
  )
})
Toast.displayName = ToastPrimitives.Root.displayName

const ToastAction = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Action>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Action
    ref={ref}
    className={cn(
      "inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors hover:bg-secondary focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive",
      className
    )}
    {...props}
  />
))
ToastAction.displayName = ToastPrimitives.Action.displayName

const ToastClose = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Close>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Close
    ref={ref}
    className={cn(
      "absolute right-2 top-2 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-2 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600",
      className
    )}
    toast-close=""
    {...props}
  >
    <span className="sr-only">Close</span>
    <svg
      xmlns="http://www.w3.org/2000/svg"
      width="16"
      height="16"
      viewBox="0 0 24 24"
      fill="none"
      stroke="currentColor"
      strokeWidth="2"
      strokeLinecap="round"
      strokeLinejoin="round"
    >
      <line x1="18" y1="6" x2="6" y2="18"></line>
      <line x1="6" y1="6" x2="18" y2="18"></line>
    </svg>
  </ToastPrimitives.Close>
))
ToastClose.displayName = ToastPrimitives.Close.displayName

const ToastTitle = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Title>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Title
    ref={ref}
    className={cn("text-sm font-semibold", className)}
    {...props}
  />
))
ToastTitle.displayName = ToastPrimitives.Title.displayName

const ToastDescription = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Description>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Description
    ref={ref}
    className={cn("text-sm opacity-90", className)}
    {...props}
  />
))
ToastDescription.displayName = ToastPrimitives.Description.displayName

type ToastProps = React.ComponentPropsWithoutRef<typeof Toast>

type ToastActionElement = React.ReactElement<typeof ToastAction>

export {
  type ToastProps,
  type ToastActionElement,
  ToastProvider,
  ToastViewport,
  Toast,
  ToastTitle,
  ToastDescription,
  ToastClose,
  ToastAction,
}

================
File: /Users/jess/Desktop/personal git/mobbin/formobbin/components/ui/tooltip.tsx
================
"use client"

import * as React from "react"
import * as TooltipPrimitive from "@radix-ui/react-tooltip"

import { cn } from "@/lib/utils"

function TooltipProvider({
  delayDuration = 0,
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Provider>) {
  return (
    <TooltipPrimitive.Provider
      data-slot="tooltip-provider"
      delayDuration={delayDuration}
      {...props}
    />
  )
}

function Tooltip({
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Root>) {
  return (
    <TooltipProvider>
      <TooltipPrimitive.Root data-slot="tooltip" {...props} />
    </TooltipProvider>
  )
}

function TooltipTrigger({
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Trigger>) {
  return <TooltipPrimitive.Trigger data-slot="tooltip-trigger" {...props} />
}

function TooltipContent({
  className,
  sideOffset = 0,
  children,
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Content>) {
  return (
    <TooltipPrimitive.Portal>
      <TooltipPrimitive.Content
        data-slot="tooltip-content"
        sideOffset={sideOffset}
        className={cn(
          "bg-primary text-primary-foreground animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-fit origin-(--radix-tooltip-content-transform-origin) rounded-md px-3 py-1.5 text-xs text-balance",
          className
        )}
        {...props}
      >
        {children}
        <TooltipPrimitive.Arrow className="bg-primary fill-primary z-50 size-2.5 translate-y-[calc(-50%_-_2px)] rotate-45 rounded-[2px]" />
      </TooltipPrimitive.Content>
    </TooltipPrimitive.Portal>
  )
}

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }

================
File: /Users/jess/Desktop/personal git/mobbin/formobbin/components/upload/batch-card/batch-header.tsx
================
import { Button } from "@/components/ui/button";
import { FileImage, ChevronUp, ChevronDown, ClipboardCheck, ExternalLink } from "lucide-react";
import { StatusBadge } from "./status-badge";
import { PerformanceTooltip } from "./performance-tooltip";
import type { Batch } from "@/types/batch";

interface BatchHeaderProps {
  batch: Batch;
  isExpanded: boolean;
  onToggle: () => void;
  onViewResults: (batchId: string) => void;
}

export const BatchHeader = ({ batch, isExpanded, onToggle, onViewResults }: BatchHeaderProps) => (
  <div className="flex-1">
    <div className="flex items-center justify-between mb-1">
      <h3 className="font-medium">{batch.name}</h3>
      <div className="flex items-center gap-2">
        <StatusBadge status={batch.status} />
        {batch.status === 'extracting' && (
          <Button 
            variant="outline" 
            size="default" 
            className="flex items-center gap-1 h-6 px-2"
            onClick={(e) => {
              e.stopPropagation();
              onViewResults(batch.id);
            }}
          >
            <ExternalLink className="h-3 w-3" />
            <span className="text-xs">View Result</span>
          </Button>
        )}
        <Button 
          variant="ghost" 
          size="icon" 
          className="flex items-center gap-1 h-6 px-2"
          onClick={onToggle}
        >
          {isExpanded ? <ChevronUp className="h-3 w-3" /> : <ChevronDown className="h-3 w-3" />}
        </Button>
      </div>
    </div>
    <div className="flex flex-wrap items-center text-sm text-muted-foreground mt-1">
      <div className="flex items-center gap-2 mr-4">
        <FileImage className="h-4 w-4" />
        {batch.images.length} {batch.images.length === 1 ? "image" : "images"}
      </div>
      {batch.analysisType && (
        <div className="flex items-center gap-2 mr-4">
          <ClipboardCheck className="h-4 w-4" />
          <span>{batch.analysisType}</span>
        </div>
      )}
      {batch.performance && <PerformanceTooltip performance={batch.performance} />}
    </div>
  </div>
);

================
File: /Users/jess/Desktop/personal git/mobbin/formobbin/components/upload/batch-card/constants.ts
================
export const DATE_FORMAT_OPTIONS: Intl.DateTimeFormatOptions = {
  year: "numeric",
  month: "short",
  day: "numeric",
  hour: "2-digit",
  minute: "2-digit",
  timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone
};

export const STATUS_BADGE_CONFIG = {
  uploading: {
    icon: "Loader2",
    label: "Uploading",
    className: "bg-blue-50 text-blue-700 border-blue-200"
  },
  extracting: {
    icon: "Zap",
    label: "Extracting UI",
    className: "bg-amber-50 text-amber-700 border-amber-200"
  },
  annotating: {
    icon: "Pencil",
    label: "Annotating",
    className: "bg-purple-50 text-purple-700 border-purple-200"
  },
  preview: {
    icon: "Eye",
    label: "Preview Available",
    className: "bg-green-50 text-green-700 border-green-200"
  },
  done: {
    icon: "CheckCircle",
    label: "Done",
    className: "bg-green-100 text-green-800 border-green-300"
  }
} as const;

================
File: /Users/jess/Desktop/personal git/mobbin/formobbin/components/upload/batch-card/image-grid.tsx
================
import { ScrollArea } from "@/components/ui/scroll-area";
import { ImageCard } from "../image-card";
import type { Batch } from "@/types/batch";

interface ImageGridProps {
  images: Batch["images"];
  onImageSelect: (index: number) => void;
}

export const ImageGrid = ({ images, onImageSelect }: ImageGridProps) => (
  <div className="p-4">
    <ScrollArea className="h-[300px]">
      <div className="grid grid-cols-1 xs:grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-4">
        {images.map((image, index) => (
          <ImageCard
            key={image.id}
            file={image}
            index={index}
            // onClick={() => onImageSelect(index)}
            onClick={() => {}}
            isUploadMode={false}
          />
        ))}
      </div>
    </ScrollArea>
  </div>
);

================
File: /Users/jess/Desktop/personal git/mobbin/formobbin/components/upload/batch-card/index.tsx
================
import { Separator } from "@/components/ui/separator";
import { BatchHeader } from "./batch-header";
import { PerformanceStats } from "./performance-stats";
import { ImageGrid } from "./image-grid";
import type { Batch } from "@/types/batch";
// import { BatchCard } from "@/components/upload/batch-card";

interface BatchCardProps {
  batch: Batch;
  isExpanded: boolean;
  onToggle: () => void;
  onImageSelect: (imageIndex: number) => void;
  onViewResults: (batchId: string) => void;
}

export function BatchCard({ batch, isExpanded, onToggle, onImageSelect, onViewResults }: BatchCardProps) {
  return (
    <div className="rounded-md border border-border overflow-hidden">
      <div
        className="p-4 flex items-center justify-between cursor-pointer hover:bg-muted/50 transition-colors"
        onClick={onToggle}
      >
        <BatchHeader batch={batch} isExpanded={isExpanded} onToggle={onToggle} onViewResults={(batchId) => onViewResults(batchId)   } />
      </div>

      {batch.performance && isExpanded && <PerformanceStats performance={batch.performance} />}

      {isExpanded && (
        <>
          <Separator />
          <ImageGrid images={batch.images} onImageSelect={onImageSelect} />
        </>
      )}
    </div>
  );
}

================
File: /Users/jess/Desktop/personal git/mobbin/formobbin/components/upload/batch-card/performance-stats.tsx
================
import type { Batch } from "@/types/batch";

interface PerformanceStatsProps {
  performance: Batch["performance"];
}

export const PerformanceStats = ({ performance }: PerformanceStatsProps) => (
  <div className="px-4 py-2 bg-muted/30 border-t border-b">
    <div className="grid grid-cols-3 gap-2 text-sm">
      <div className="flex flex-col items-center p-2 rounded-md bg-background">
        <span className="text-muted-foreground text-xs">Master Prompt</span>
        <span className="font-medium">{performance?.masterPromptRuntime.toFixed(1)}s</span>
      </div>
      <div className="flex flex-col items-center p-2 rounded-md bg-background">
        <span className="text-muted-foreground text-xs">Inference Time</span>
        <span className="font-medium">{performance?.totalInferenceTime.toFixed(1)}s</span>
      </div>
      <div className="flex flex-col items-center p-2 rounded-md bg-background">
        <span className="text-muted-foreground text-xs">Elements</span>
        <span className="font-medium">{performance?.detectedElementsCount}</span>
      </div>
    </div>
  </div>
);

================
File: /Users/jess/Desktop/personal git/mobbin/formobbin/components/upload/batch-card/performance-tooltip.tsx
================
import { Button } from "@/components/ui/button";
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip";
import { BarChart } from "lucide-react";
import type { Batch } from "@/types/batch";

interface PerformanceTooltipProps {
  performance: Batch["performance"];
}

export const PerformanceTooltip = ({ performance }: PerformanceTooltipProps) => (
  <div className="flex items-center ml-4">
    <TooltipProvider>
      <Tooltip>
        <TooltipTrigger asChild>
          <Button variant="ghost" size="icon" className="flex items-center gap-1">
            <BarChart className="h-4 w-4 text-muted-foreground" />
            <span>Insight</span>
          </Button>
        </TooltipTrigger>
        <TooltipContent>
          <div className="text-xs">
            <p>Master Prompt: {performance?.masterPromptRuntime.toFixed(1)}s</p>
            <p>Total Inference: {performance?.totalInferenceTime.toFixed(1)}s</p>
            <p>Elements: {performance?.detectedElementsCount}</p>
          </div>
        </TooltipContent>
      </Tooltip>
    </TooltipProvider>
  </div>
);

================
File: /Users/jess/Desktop/personal git/mobbin/formobbin/components/upload/batch-card/status-badge.tsx
================
import { Badge } from "@/components/ui/badge";
import { STATUS_BADGE_CONFIG } from "./constants";
import { Loader2, Zap, Pencil, Eye, CheckCircle } from "lucide-react";
import type { Batch } from "@/types/batch";

const iconComponents = {
  Loader2,
  Zap,
  Pencil,
  Eye,
  CheckCircle
} as const;

interface StatusBadgeProps {
  status: Batch["status"];
}

export const StatusBadge = ({ status }: StatusBadgeProps) => {
  const config = STATUS_BADGE_CONFIG[status];
  if (!config) return null;

  const IconComponent = iconComponents[config.icon];

  return (
    <Badge variant="outline" className={`${config.className} flex items-center gap-1`}>
      <IconComponent className="h-3 w-3" />
      <span>{config.label}</span>
    </Badge>
  );
};

================
File: /Users/jess/Desktop/personal git/mobbin/formobbin/components/upload/batch-card/utils.ts
================
import { DATE_FORMAT_OPTIONS } from "./constants";

export const formatDate = (date: Date): string => {
  try {
    if (!(date instanceof Date) || isNaN(date.getTime())) {
      return 'Invalid date';
    }
    return new Intl.DateTimeFormat("en-US", DATE_FORMAT_OPTIONS).format(date);
  } catch (error) {
    console.error('Error formatting date:', error);
    return 'Invalid date';
  }
};

================
File: /Users/jess/Desktop/personal git/mobbin/formobbin/components/upload/batch-display.tsx
================
// TODO: This component is not used anymore, but it's kept here for reference
// TODO: Remove this file once the new upload interface is fully implementeds

import useSWR from 'swr'
import Image from 'next/image'
import type { Batch } from '@/types/batch'

const fetcher = (url: string) => fetch(url).then(res => res.json())

export function BatchDisplay() {
  const { data: batches, error, isLoading } = useSWR<Batch[]>('/api/batches', fetcher)

  // if (isLoading) return <div>Loading batches...</div>
  if (error) return <div>Error loading batches</div>
  if (!batches) return null

  return (
    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 p-4">
      {batches.map((batch: Batch) => (
        <div key={batch.id} className="border rounded-lg p-4 shadow-sm">
          <h3 className="font-semibold mb-2">{batch.name}</h3>
          <p className="text-sm text-gray-600 mb-2">
            {new Date(batch.timestamp).toLocaleDateString()}
          </p>
          <div className="grid grid-cols-2 gap-2">
            {batch.images.map((image) => (
              <div key={image.id} className="relative aspect-square">
                <Image
                  src={image.url}
                  alt={image.name}
                  fill
                  className="object-cover rounded"
                />
              </div>
            ))}
          </div>
        </div>
      ))}
    </div>
  )
}

================
File: /Users/jess/Desktop/personal git/mobbin/formobbin/components/upload/batch-list.tsx
================
import type { Batch } from "@/types/batch"
import { BatchCard } from "@/components/upload/batch-card"
// import { RevealOnHover } from "@/components/ui/reveal-on-hover"

interface BatchListProps {
  batches: Batch[]
  expandedBatchId: string | null
  toggleBatch: (batchId: string) => void
  onImageSelect: (batchId: string, imageIndex: number) => void
  onViewResults: (batchId: string) => void
}

export function BatchList({ 
  batches, 
  expandedBatchId, 
  toggleBatch, 
  onImageSelect,
  onViewResults,
}: BatchListProps) {
  return (
    <div className="mt-4">
      <h2 className="text-xl font-medium mb-4">Batches ({batches.length})</h2>
      <div className="space-y-3">
        {batches.map((batch) => (
            <BatchCard
              key={batch.id}
              batch={batch}
              isExpanded={expandedBatchId === batch.id}
              onToggle={() => toggleBatch(batch.id)}
              onImageSelect={(imageIndex: number) => onImageSelect(batch.id, imageIndex)}
              onViewResults={() => onViewResults(batch.id)}
            />
        ))}
      </div>
    </div>
  )
}

================
File: /Users/jess/Desktop/personal git/mobbin/formobbin/components/upload/dropzone-area.tsx
================
import { useDropzone } from "react-dropzone"
import { Upload, ImageIcon, FolderOpen } from "lucide-react"
import { Button } from "@/components/ui/button"

interface DropzoneAreaProps {
  isDragging: boolean
  setIsDragging: (isDragging: boolean) => void
  onDrop: (acceptedFiles: File[]) => void
}

export function DropzoneArea({ isDragging, setIsDragging, onDrop }: DropzoneAreaProps) {
  const { getRootProps, getInputProps } = useDropzone({
    onDrop,
    accept: {
      "image/*": [],
    },
    onDragEnter: () => setIsDragging(true),
    onDragLeave: () => setIsDragging(false),
  })

  return (
    <div
      {...getRootProps()}
      className={`border-2 border-dashed rounded-lg p-6 md:p-10 text-center cursor-pointer transition-colors
        ${isDragging ? "border-primary bg-primary/5" : "border-muted-foreground/25 hover:border-primary/50"}`}
    >
      <input {...getInputProps()} />
      <Upload className="mx-auto h-10 w-10 md:h-12 md:w-12 text-muted-foreground mb-4" />
      <h2 className="text-lg md:text-xl font-medium mb-2">Drag & drop images here</h2>
      <p className="text-muted-foreground mb-4">Or click to browse files (up to 20 images)</p>
      <div className="flex flex-col sm:flex-row justify-center gap-3">
        <Button className="w-full sm:w-auto">
          <ImageIcon className="mr-2 h-4 w-4" />
          Select Images
        </Button>
        <Button variant="outline" className="w-full sm:w-auto">
          <FolderOpen className="mr-2 h-4 w-4" />
          Select Folder
        </Button>
      </div>
    </div>
  )
}

================
File: /Users/jess/Desktop/personal git/mobbin/formobbin/components/upload/image-card.tsx
================
import { FileImage, X } from "lucide-react"
import { Button } from "@/components/ui/button"
import { Card, CardContent } from "@/components/ui/card"
import Image from "next/image"

type FileType = {
  id: string
  name: string
  url: string
} | File

interface ImageCardProps {
  file: FileType
  index: number
  onClick: () => void
  onRemove?: (index: number) => void
  isUploadMode?: boolean
}

export function ImageCard({ 
  file, 
  index, 
  onClick, 
  onRemove,
  isUploadMode = false 
}: ImageCardProps) {
  const handleRemoveClick = (e: React.MouseEvent) => {
    e.stopPropagation()
    onRemove?.(index)
  }

  const getImageUrl = () => {
    if (file instanceof File) {
      return URL.createObjectURL(file)
    }
    return file.url
  }

  const getFileName = () => {
    if (file instanceof File) {
      return file.name
    }
    return file.name
  }

  const cardClassName = `relative group cursor-pointer hover:shadow-md transition-shadow`

  return (
    <Card 
      className={cardClassName}
      onClick={onClick}
    >
      <CardContent className="p-2">
      <div className="aspect-square relative overflow-hidden rounded-md mb-2">
        <Image
          src={getImageUrl()}
          alt={getFileName()}
          fill
          sizes="(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw"
          className="object-cover"
        />
        {isUploadMode && onRemove && (
          <Button
            variant="destructive"
            size="icon"
            className="absolute top-1 right-1 h-6 w-6 opacity-0 group-hover:opacity-100 transition-opacity"
            onClick={handleRemoveClick}
          >
            <X className="h-3 w-3" />
          </Button>
        )}
        <div className="absolute bottom-0 left-0 right-0 p-2 bg-background/80 text-xs truncate">
          {getFileName()}
        </div>
      </div>
      </CardContent>
    </Card>
  )
}

================
File: /Users/jess/Desktop/personal git/mobbin/formobbin/components/upload/selected-images-panel.tsx
================
import { Upload } from "lucide-react"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { ScrollArea } from "@/components/ui/scroll-area"
import { ImageCard } from "./image-card"
import { 
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue 
} from "@/components/ui/select"
import { Toast, ToastProvider, ToastViewport, ToastTitle, ToastDescription } from "@/components/ui/toast"
import React from "react"

// Define analysis types as constants to avoid magic strings
const ANALYSIS_TYPES = {
    USABILITY: 'Usability Audit',
    MARKETING: 'Conversion Analysis',
    // ACCESSIBILITY: 'Inclusive Design Audit',
    TAXONOMY: 'UI Categorization'
  }  

interface SelectedImagesPanelProps {
  selectedFiles: File[]
  batchName: string
  setBatchName: (name: string) => void
  onRemoveFile: (index: number) => void
  onUploadBatch: (files: File[], batchName: string, analysisType: string) => void
  analysisType: string
  setAnalysisType: (type: string) => void
  onRefetchBatches: () => void
}

export function SelectedImagesPanel({
  selectedFiles,
  batchName,
  setBatchName,
  onRemoveFile,
  onUploadBatch,
  analysisType,
  setAnalysisType,
  onRefetchBatches,
}: SelectedImagesPanelProps) {
  const [showToast, setShowToast] = React.useState(false);
  const [isUploading, setIsUploading] = React.useState(false);

  const handleUpload = async () => {
    if (!analysisType) {
      setShowToast(true);
      return;
    }
    
    setIsUploading(true);
    try {
      await onUploadBatch(selectedFiles, batchName, analysisType);
    } catch (error) {
      console.error('Upload failed:', error);
      // You might want to show an error toast here
    } finally {
      setIsUploading(false);
    }
  };

  return (
    <ToastProvider>
      <div>
        <div className="flex flex-col sm:flex-row justify-between items-start sm:items-center mb-4">
          <h2 className="text-xl font-medium">Selected Images ({selectedFiles.length})</h2>
          <div className="flex flex-col sm:flex-row gap-3 mt-2 sm:mt-0 w-full sm:w-auto">
            <div className="flex-1 sm:flex-initial">
              <Input
                placeholder="Batch Name (optional)"
                value={batchName}
                onChange={(e) => setBatchName(e.target.value)}
                className="w-full"
              />
            </div>
            
            <Select 
              value={analysisType} 
              onValueChange={(value) => setAnalysisType(value)}
            >
              <SelectTrigger className="w-full sm:w-[220px]">
                <SelectValue placeholder="Select Analysis Type" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value={ANALYSIS_TYPES.USABILITY}>
                  {ANALYSIS_TYPES.USABILITY}
                </SelectItem>
                <SelectItem value={ANALYSIS_TYPES.MARKETING}>
                  {ANALYSIS_TYPES.MARKETING}
                </SelectItem>
                {/* <SelectItem value={ANALYSIS_TYPES.ACCESSIBILITY}>
                  {ANALYSIS_TYPES.ACCESSIBILITY}
                </SelectItem> */}
                <SelectItem value={ANALYSIS_TYPES.TAXONOMY}>
                  {ANALYSIS_TYPES.TAXONOMY}
                </SelectItem>
              </SelectContent>
            </Select>
            
            <Button 
              className="w-full sm:w-auto" 
              onClick={handleUpload} 
              disabled={isUploading}
            >
              {isUploading ? (
                <>
                  <span className="animate-spin mr-2"></span>
                  Uploading...
                </>
              ) : (
                <>
                  <Upload className="mr-2 h-4 w-4" />
                  Upload Batch
                </>
              )}
            </Button>
          </div>
        </div>

        <ScrollArea className="h-[300px] md:h-[400px] rounded-md border">
          <div className="grid grid-cols-1 xs:grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-4 p-4">
            {selectedFiles.map((file, index) => (
              <ImageCard
                key={`${file.name}-${index}`}
                file={file}
                index={index}
                onRemove={onRemoveFile}
                isUploadMode={true} 
                onClick={() => {}}
              />
            ))}
          </div>
        </ScrollArea>
      </div>
      
      {showToast && (
        <Toast variant="default" onOpenChange={setShowToast}>
          <ToastTitle>Analysis type required</ToastTitle>
          <ToastDescription>
            Please select an analysis type before uploading.
          </ToastDescription>
        </Toast>
      )}
      
      <ToastViewport />
    </ToastProvider>
  )
}

================
File: /Users/jess/Desktop/personal git/mobbin/formobbin/components/annotation-editor.tsx
================
"use client"

import type React from "react"

import { useState, useRef, useEffect } from "react"
import { ArrowLeft, Save, ChevronUp, ChevronDown, Loader2 } from "lucide-react"
import { Button } from "@/components/ui/button"
import { ControlPanel } from "@/components/control-panel"
import { useIsMobile } from "@/hooks/use-mobile"
import { useImageScale } from "../hooks/use-image-scale"
import { useBoxInteraction } from "../hooks/use-box-interaction"
import { AnnotationCanvas } from "../components/annotation/annotation-canvas"
import { AnnotationHeader } from "../components/annotation/annotation-header"
import { BoundingBox } from "@/types/annotation"
import { useAnnotationState } from "../hooks/use-annotation-state"

// Mock data for demonstration purposes
const mockBoundingBoxes = [
  {
    id: 1,
    label: "Button",
    textLabel: "Submit",
    description: "Main action button",
    x: 50,
    y: 100,
    width: 120,
    height: 40,
    inferenceTime: 0.78,
  },
  {
    id: 2,
    label: "Tab Bar",
    textLabel: "Navigation",
    description: "Main navigation tabs",
    x: 200,
    y: 50,
    width: 300,
    height: 60,
    inferenceTime: 1.25,
  },
  {
    id: 3,
    label: "Text Field",
    textLabel: "Username",
    description: "Username input field",
    x: 100,
    y: 200,
    width: 200,
    height: 40,
    inferenceTime: 0.92,
  },
  {
    id: 4,
    label: "Checkbox",
    textLabel: "Remember me",
    description: "Session persistence option",
    x: 400,
    y: 300,
    width: 30,
    height: 30,
    inferenceTime: 0.65,
  },
  {
    id: 5,
    label: "Dropdown",
    textLabel: "Country",
    description: "Country selection dropdown",
    x: 500,
    y: 150,
    width: 150,
    height: 40,
    inferenceTime: 1.12,
  },
]


interface AnnotationEditorProps {
  image: {
    id: string
    name: string
    url: string
  }
  onBack: () => void
  onNextImage?: () => void
  onPreviousImage?: () => void
}

export function AnnotationEditor({ image, onBack, onNextImage, onPreviousImage }: AnnotationEditorProps) {
  // Use our centralized annotation state
  const {
    boundingBoxes,
    selectedBox,
    editingLabelId,
    editingLabelText,
    setEditingLabelId,
    setEditingLabelText,
    updateBox,
    selectBox,
    deleteBox,
    updateLabelAndFinishEditing,
    dragState,
    resizeState,
    setDragState,
    setResizeState
  } = useAnnotationState(mockBoundingBoxes)

  const [masterPromptRuntime, setMasterPromptRuntime] = useState<number>(1.8) // in seconds
  const [isPanelCollapsed, setIsPanelCollapsed] = useState(false)
  const [isImageLoading, setIsImageLoading] = useState(true)
  // const isMobile = useIsMobile()  // Commented out mobile check
  
  const containerRef = useRef<HTMLDivElement>(document.createElement('div'))
  const imageRef = useRef<HTMLImageElement>(document.createElement('img'))
  const controlPanelRef = useRef<HTMLDivElement>(null) // Add ref for control panel
  
  // Custom hooks
  const { scale } = useImageScale(image.url, containerRef, imageRef)
  
  // Handle image load
  useEffect(() => {
    const handleImageLoad = () => {
      setIsImageLoading(false)
    }

    if (imageRef.current) {
      imageRef.current.onload = handleImageLoad
      // Reset loading state if image URL changes
      setIsImageLoading(true)
    }
  }, [image.url])

  // Use the useBoxInteraction hook with our centralized state
  const { startDragging, startResizing } = useBoxInteraction({
    containerRef,
    scale,
    updateBox,
    selectBox,
    setDragState,
    setResizeState
  })

  // Handle click outside canvas and control panel to deselect
  useEffect(() => {
    const handleClickOutside = (e: MouseEvent) => {
      if (
        containerRef.current && 
        !containerRef.current.contains(e.target as Node) &&
        controlPanelRef.current && 
        !controlPanelRef.current.contains(e.target as Node)
      ) {
        selectBox(null)
      }
    }

    document.addEventListener('mousedown', handleClickOutside)
    return () => document.removeEventListener('mousedown', handleClickOutside)
  }, [containerRef, controlPanelRef, selectBox])

  const handleSave = () => {
    console.log("Saving annotation data:", boundingBoxes)
    // Here you would typically send the data to your backend
    alert("Annotations saved successfully!")
  }

  const togglePanel = () => {
    setIsPanelCollapsed(!isPanelCollapsed)
  }

  // Group related props
  const boxControls = {
    boundingBoxes,
    selectedBox,
    onSelect: selectBox,
    onUpdate: updateBox,
    onDelete: deleteBox,
    onDeselect: () => selectBox(null)
  }

  const labelEditing = {
    editingLabelId,
    editingLabelText,
    setEditingLabelId,
    setEditingLabelText,
    updateLabelAndFinishEditing
  }

  const imageState = {
    imageUrl: image.url,
    scale,
    imageRef,
    containerRef
  }

  const interactionHandlers = {
    startDragging,
    startResizing,
    dragState,
    resizeState
  }

  return (
    <div className="flex h-screen min-w-[800px]">
      {/* Main annotation area - fixed width and height */}
      <div className="w-[1000px] h-screen flex flex-col">
        <AnnotationHeader 
          imageName={image.name}
          onBack={onBack}
          onSave={handleSave}
        />

        <div className="flex-1 overflow-auto bg-muted/30 p-2 sm:p-4 relative">
          {isImageLoading && (
            <div className="absolute inset-0 flex items-center justify-center bg-background/80 z-10">
              <Loader2 className="h-8 w-8 animate-spin text-primary" />
            </div>
          )}
          <AnnotationCanvas
            imageState={imageState}
            boxControls={boxControls}
            labelEditing={labelEditing}
            interactionHandlers={interactionHandlers}
            isMobile={false}
          />
        </div>

        {/* Mobile panel toggle button - commented out
        {isMobile && (
          <div className="border-t border-b p-2 bg-background flex justify-center">
            <Button variant="outline" onClick={togglePanel} className="w-full flex items-center justify-center">
              {isPanelCollapsed ? (
                <>
                  <ChevronUp className="mr-2 h-4 w-4" />
                  Show Control Panel
                </>
              ) : (
                <>
                  <ChevronDown className="mr-2 h-4 w-4" />
                  Hide Control Panel
                </>
              )}
            </Button>
          </div>
        )}
        */}
      </div>

      {/* Control panel / sidebar - flexible width */}
      <div 
        ref={controlPanelRef} // Attach ref to the control panel wrapper
        className={`flex-1 border-l bg-background flex flex-col h-full min-w-[300px] ${isPanelCollapsed ? "hidden" : "flex"}`}>
        <ControlPanel
          boundingBoxes={boundingBoxes}
          selectedBox={selectedBox}
          onBoxSelect={selectBox}
          onBoxUpdate={updateBox}
          onBoxDelete={deleteBox}
          onBoxDeselect={() => selectBox(null)}
          editingLabelState={{
            editingLabelId,
            editingLabelText,
            setEditingLabelId,
            setEditingLabelText,
            updateLabelAndFinishEditing
          }}
          masterPromptRuntime={masterPromptRuntime}
          onSave={handleSave}
          onNextImage={onNextImage}
          onPreviousImage={onPreviousImage}
          isMobile={false}
        />
      </div>
    </div>
  )
}

================
File: /Users/jess/Desktop/personal git/mobbin/formobbin/components/control-panel.tsx
================
"use client"

import { useState, useMemo } from "react"
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs"
import { ControlPanelHeader } from "@/components/control-panel/control-panel-header"
import { ElementList } from "@/components/control-panel/element-list"
import { ElementEditor } from "@/components/control-panel/element-editor"
import { SummaryPanel } from "@/components/control-panel/summary-panel"
import { PanelFooterActions } from "@/components/control-panel/panel-footer-actions"
import { BoundingBox } from "@/types/annotation"
import { useControlPanelState } from "@/hooks/use-box-interaction"

interface ControlPanelProps {
  boundingBoxes: BoundingBox[]
  selectedBox: BoundingBox | null
  onBoxSelect: (box: BoundingBox) => void
  onBoxUpdate: (box: BoundingBox) => void
  onBoxDelete: (id: number) => void
  masterPromptRuntime: number
  onSave: () => void
  onNextImage?: () => void
  onPreviousImage?: () => void
  isMobile?: boolean
  onBoxDeselect: () => void
  editingLabelState: {
    editingLabelId: number | null
    editingLabelText: string
    setEditingLabelId: (id: number | null) => void
    setEditingLabelText: (text: string) => void
    updateLabelAndFinishEditing: () => void
  }
}

export function ControlPanel({
  boundingBoxes,
  selectedBox,
  onBoxSelect,
  onBoxUpdate,
  onBoxDelete,
  masterPromptRuntime,
  onSave,
  onNextImage,
  onPreviousImage,
  isMobile = false,
  onBoxDeselect,
  editingLabelState,
}: ControlPanelProps) {
  // Use the hook for UI state management
  const {
    activeTab,
    setActiveTab,
    hoveredBoxId,
    setHoveredBoxId,
    view,
    setView,
    totalInferenceTime
  } = useControlPanelState(boundingBoxes)

  const handleElementSelect = (box: BoundingBox) => {
    onBoxSelect(box)
    setView("edit")
  }

  const handleBackToList = () => {
    onBoxDeselect()
    setView("list")
  }

  const handleExportAnnotations = () => {
    const annotationData = {
      masterPromptRuntime,
      totalInferenceTime,
      elements: boundingBoxes,
    }

    const dataStr = JSON.stringify(annotationData, null, 2)
    const dataUri = "data:application/json;charset=utf-8," + encodeURIComponent(dataStr)

    const exportFileDefaultName = "annotations.json"

    const linkElement = document.createElement("a")
    linkElement.setAttribute("href", dataUri)
    linkElement.setAttribute("download", exportFileDefaultName)
    linkElement.click()
  }

  // Mobile view uses tabs
  if (isMobile) {
    return (
      <div className="flex flex-col h-full">
        <Tabs defaultValue="elements" value={activeTab} onValueChange={setActiveTab} className="w-full">
          <div className="px-4 pt-4 border-b sticky top-0 bg-background z-10">
            <TabsList className="w-full grid grid-cols-3">
              <TabsTrigger value="elements">Elements</TabsTrigger>
              <TabsTrigger value="editor">Editor</TabsTrigger>
              <TabsTrigger value="summary">Summary</TabsTrigger>
            </TabsList>
          </div>

          <TabsContent value="elements" className="mt-0 p-0">
            <ElementList
              boundingBoxes={boundingBoxes}
              selectedBox={selectedBox}
              hoveredBoxId={hoveredBoxId}
              setHoveredBoxId={setHoveredBoxId}
              onBoxSelect={onBoxSelect}
              onBoxDelete={onBoxDelete}
            />
          </TabsContent>

          <TabsContent value="editor" className="mt-0 p-0">
            {selectedBox ? (
              <ElementEditor
                selectedBox={selectedBox}
                onBoxUpdate={onBoxUpdate}
                onBoxDelete={onBoxDelete}
                onBackToList={handleBackToList}
                editingLabelState={editingLabelState}
              />
            ) : (
              <div className="p-4 text-center text-muted-foreground">Select an element to edit its properties</div>
            )}
          </TabsContent>

          <TabsContent value="summary" className="mt-0 p-0">
            <SummaryPanel
              masterPromptRuntime={masterPromptRuntime}
              totalInferenceTime={totalInferenceTime}
              elementCount={boundingBoxes.length}
            />
          </TabsContent>
        </Tabs>

        <PanelFooterActions
          onSave={onSave}
          onExport={handleExportAnnotations}
          onPreviousImage={onPreviousImage}
          onNextImage={onNextImage}
        />
      </div>
    )
  }

  // Desktop view - now with separate list and edit views
  return (
    <div className="flex flex-col h-full">
      {/* List View */}
      {view === "list" && (
        <>
          <ControlPanelHeader
            title="Performance Summary"
            masterPromptRuntime={masterPromptRuntime}
            totalInferenceTime={totalInferenceTime}
          />

          <div className="p-4 border-b">
            <h3 className="text-lg font-medium">Detected Elements</h3>
            <p className="text-sm text-muted-foreground">{boundingBoxes.length} elements found</p>
          </div>

          <ElementList
            boundingBoxes={boundingBoxes}
            selectedBox={selectedBox}
            hoveredBoxId={hoveredBoxId}
            setHoveredBoxId={setHoveredBoxId}
            onBoxSelect={handleElementSelect}
            onBoxDelete={onBoxDelete}
          />

          <PanelFooterActions
            onSave={onSave}
            onExport={handleExportAnnotations}
            onPreviousImage={onPreviousImage}
            onNextImage={onNextImage}
          />
        </>
      )}

      {/* Edit View */}
      {view === "edit" && selectedBox && (
        <ElementEditor
          selectedBox={selectedBox}
          onBoxUpdate={onBoxUpdate}
          onBoxDelete={onBoxDelete}
          onBackToList={handleBackToList}
          editingLabelState={editingLabelState}
        />
      )}
    </div>
  )
}

================
File: /Users/jess/Desktop/personal git/mobbin/formobbin/components/element-list-item.tsx
================
"use client"
import { motion, AnimatePresence } from "framer-motion"
import { Trash2, Eye, Clock, ChevronDown, ChevronUp } from "lucide-react"
import { Button } from "@/components/ui/button"
import { Card, CardContent } from "@/components/ui/card"
import { BoundingBox } from "@/types/annotation"

interface ElementListItemProps {
  box: BoundingBox
  isSelected: boolean
  isExpanded: boolean
  onSelect: (box: BoundingBox) => void
  onDelete: (id: number) => void
  onToggleExpand: (id: number) => void
  isMobile: boolean
}

export function ElementListItem({
  box,
  isSelected,
  isExpanded,
  onSelect,
  onDelete,
  onToggleExpand,
  isMobile,
}: ElementListItemProps) {
  const handleClick = () => {
    if (isMobile) {
      onSelect(box)
    } else {
      onToggleExpand(box.id)
    }
  }

  return (
    <Card className={`cursor-pointer transition-colors ${isSelected ? "border-primary" : ""}`} onClick={handleClick}>
      <CardContent className="p-3">
        <div className="flex items-center justify-between">
          <div className="max-w-[70%]">
            <div className="font-medium break-words">{box.textLabel}</div>
          </div>
          <div className="flex gap-1">
            {!isMobile && (
              <Button
                variant="ghost"
                size="icon"
                className="h-7 w-7"
                onClick={(e) => {
                  e.stopPropagation()
                  onToggleExpand(box.id)
                }}
              >
                {isExpanded ? <ChevronUp className="h-4 w-4" /> : <ChevronDown className="h-4 w-4" />}
              </Button>
            )}
          </div>
        </div>

        <AnimatePresence>
          {isExpanded && (
            <motion.div
              initial={{ height: 0, opacity: 0 }}
              animate={{ height: "auto", opacity: 1 }}
              exit={{ height: 0, opacity: 0 }}
              transition={{ duration: 0.2 }}
              className="overflow-hidden"
            >
              <div className="mt-2 pt-2 border-t">
                <div className="text-xs text-muted-foreground">
                  <span className="font-medium">Type:</span> {box.label}
                </div>
                <div
                  className="text-xs text-muted-foreground mt-1"
                  key={`${box.x}-${box.y}-${box.width}-${box.height}`}
                >
                  <span className="font-medium">Position:</span> x: {box.x}, y: {box.y}, w: {box.width}, h: {box.height}
                </div>
                <div className="text-xs flex items-center mt-1 text-muted-foreground">
                  <Clock className="h-3 w-3 mr-1" />
                  Inference Time: {box.inferenceTime.toFixed(2)}s
                </div>
                <div className="flex gap-1 mt-2">
                  <Button
                    variant="outline"
                    size="sm"
                    className="h-7 text-xs flex-1"
                    onClick={(e) => {
                      e.stopPropagation()
                      onSelect(box)
                    }}
                  >
                    <Eye className="h-3 w-3 mr-1" />
                    Edit
                  </Button>
                  <Button
                    variant="outline"
                    size="sm"
                    className="h-7 text-xs flex-1 text-destructive hover:text-destructive"
                    onClick={(e) => {
                      e.stopPropagation()
                      onDelete(box.id)
                    }}
                  >
                    <Trash2 className="h-3 w-3 mr-1" />
                    Delete
                  </Button>
                </div>
              </div>
            </motion.div>
          )}
        </AnimatePresence>
      </CardContent>
    </Card>
  )
}

================
File: /Users/jess/Desktop/personal git/mobbin/formobbin/components/upload-interface.tsx
================
"use client"

import { useState, useCallback } from "react"
import { Loader2 } from "lucide-react"
import type { Batch } from "@/types/batch"
import { useIsMobile } from "@/hooks/use-mobile"
import { useBatchManagement } from "@/hooks/use-batch-management"
import { filterAndLimitImageFiles, removeFileAtIndex } from "@/lib/file-utils"
import { uploadFiles } from "@/services/upload-service"
import { TOAST_MESSAGES } from "@/lib/constants"
import { DropzoneArea } from "@/components/upload/dropzone-area"
import { SelectedImagesPanel } from "@/components/upload/selected-images-panel"
import { BatchList } from "@/components/upload/batch-list"
import { Toast, ToastProvider, ToastViewport, ToastTitle, ToastDescription } from "@/components/ui/toast"

interface UploadInterfaceProps {
  selectedFiles: File[]
  onFilesSelected: (files: File[]) => void
  onUploadBatch: (batchName: string, analysisType: string, uploadedFiles: File[]) => void
  onImageSelect: (batchId: string, imageIndex: number) => void
  onViewResults: (batchId: string) => void
  onRefetchBatches: () => void
}

export function UploadInterface({
  selectedFiles,
  onFilesSelected,
  onUploadBatch,
  onImageSelect,
  onViewResults,
  onRefetchBatches,
}: UploadInterfaceProps) {
  const [isDragging, setIsDragging] = useState(false)
  const [batchName, setBatchName] = useState("")
  const [analysisType, setAnalysisType] = useState("")
  const isMobile = useIsMobile()
  
  const {
    batches,
    error,
    isLoading,
    mutate,
    expandedBatchId,
    toggleBatch,
    showToast,
    setShowToast,
    generateDefaultBatchName,
  } = useBatchManagement()

  const handleFileDrop = useCallback(
    (acceptedFiles: File[]) => {
      const combinedFiles = filterAndLimitImageFiles(acceptedFiles, selectedFiles)
      onFilesSelected(combinedFiles)
      setIsDragging(false)
    },
    [onFilesSelected, selectedFiles],
  )

  const handleFileRemove = (index: number) => {
    const newFiles = removeFileAtIndex(selectedFiles, index)
    onFilesSelected(newFiles)
  }

  const handleUpload = async (files: File[], batchName: string, analysisType: string) => {
    const finalBatchName = batchName.trim() || generateDefaultBatchName()
    
    const result = await uploadFiles(files, finalBatchName, analysisType)
    
    if (result.success) {
      onUploadBatch(finalBatchName, analysisType, files)
      await mutate()
    } else {
      setShowToast(true)
    }
  }

  return (
    <div className="container mx-auto py-6 md:py-10 px-4">
      <h1 className="text-2xl md:text-3xl font-bold mb-6 md:mb-8 text-center">Annotation Tool</h1>

      <div className="flex flex-col gap-8">
        <DropzoneArea 
          isDragging={isDragging}
          setIsDragging={setIsDragging}
          onDrop={handleFileDrop}
        />

        {selectedFiles.length > 0 && (
          <SelectedImagesPanel
            selectedFiles={selectedFiles}
            batchName={batchName}
            setBatchName={setBatchName}
            onRemoveFile={handleFileRemove}
            onUploadBatch={handleUpload}
            analysisType={analysisType}
            setAnalysisType={setAnalysisType}
            onRefetchBatches={onRefetchBatches}
          />
        )}

        {isLoading ? (
          <div className="flex items-center justify-center h-full">
            <div className="flex flex-col items-center">
              <Loader2 className="h-8 w-8 animate-spin" />
              <p className="mt-4 text-lg">{TOAST_MESSAGES.LOADING_BATCHES}</p>
            </div>
          </div>
        ) : error ? (
          <div>Error loading batches</div>
        ) : batches ? (
          <BatchList
            batches={batches}
            expandedBatchId={expandedBatchId}
            toggleBatch={toggleBatch}
            onImageSelect={onImageSelect}
            onViewResults={onViewResults}
          />
        ) : null}
      </div>

      <ToastProvider>
        <Toast open={showToast} onOpenChange={setShowToast}>
          <ToastTitle>Error</ToastTitle>
          <ToastDescription>{TOAST_MESSAGES.UPLOAD_ERROR}</ToastDescription>
        </Toast>
        <ToastViewport />
      </ToastProvider>
    </div>
  )
}

================
File: /Users/jess/Desktop/personal git/mobbin/formobbin/hooks/use-annotation-state.tsx
================
import { useState, useCallback, useRef } from "react"
import { BoundingBox } from "@/types/annotation"

interface AnnotationState {
  boundingBoxes: BoundingBox[]
  selectedBox: BoundingBox | null
  editingLabelId: number | null
  editingLabelText: string
  dragState: {
    isDragging: boolean
    startX: number
    startY: number
    originalBox: BoundingBox | null
  }
  resizeState: {
    isResizing: boolean
    handle: string | null
    startX: number
    startY: number
    originalBox: BoundingBox | null
  }
}

export function useAnnotationState(initialBoxes: BoundingBox[]) {
  // Use refs for frequently updated values to avoid re-renders
  const dragStateRef = useRef({
    isDragging: false,
    startX: 0,
    startY: 0,
    originalBox: null as BoundingBox | null
  })

  const resizeStateRef = useRef({
    isResizing: false,
    handle: null as string | null,
    startX: 0,
    startY: 0,
    originalBox: null as BoundingBox | null
  })

  // Core state management
  const [state, setState] = useState<AnnotationState>({
    boundingBoxes: initialBoxes,
    selectedBox: null,
    editingLabelId: null,
    editingLabelText: "",
    dragState: dragStateRef.current,
    resizeState: resizeStateRef.current
  })

  // Box manipulation methods
  const updateBox = useCallback((updatedBox: BoundingBox) => {
    setState(current => {
      // Only update if the box has actually changed
      const existingBox = current.boundingBoxes.find(box => box.id === updatedBox.id)
      if (existingBox && 
          existingBox.x === updatedBox.x &&
          existingBox.y === updatedBox.y &&
          existingBox.width === updatedBox.width &&
          existingBox.height === updatedBox.height) {
        return current
      }

      return {
        ...current,
        boundingBoxes: current.boundingBoxes.map(box => 
          box.id === updatedBox.id ? updatedBox : box
        ),
        selectedBox: current.selectedBox?.id === updatedBox.id ? updatedBox : current.selectedBox
      }
    })
  }, [])

  const selectBox = useCallback((box: BoundingBox | null) => {
    setState(current => ({
      ...current,
      selectedBox: box,
      editingLabelId: box ? box.id : null,
      editingLabelText: box ? box.textLabel : ""
    }))
  }, [])

  const deleteBox = useCallback((id: number) => {
    setState(current => ({
      ...current,
      boundingBoxes: current.boundingBoxes.filter(box => box.id !== id),
      selectedBox: current.selectedBox?.id === id ? null : current.selectedBox,
      editingLabelId: current.editingLabelId === id ? null : current.editingLabelId
    }))
  }, [])

  // Label editing methods
  const setEditingLabelId = useCallback((id: number | null) => {
    setState(current => {
      // If starting to edit, pre-populate with the existing label
      const editingBox = id ? current.boundingBoxes.find(box => box.id === id) : null;
      
      const nextEditingText = editingBox ? editingBox.textLabel : current.editingLabelText

      return {
        ...current,
        editingLabelId: id,
        editingLabelText: id === current.editingLabelId ? current.editingLabelText : nextEditingText
      }
    })
  }, [])

  const setEditingLabelText = useCallback((text: string) => {
    setState(current => ({
      ...current,
      editingLabelText: text
    }))
  }, [])

  const updateLabelAndFinishEditing = useCallback(() => {
    setState(current => {
      if (current.editingLabelId) {
        const updatedBoxes = current.boundingBoxes.map(box => 
          box.id === current.editingLabelId 
            ? { ...box, textLabel: current.editingLabelText } 
            : box
        );
        
        const updatedSelectedBox = current.selectedBox?.id === current.editingLabelId 
          ? { ...current.selectedBox, textLabel: current.editingLabelText } 
          : current.selectedBox;
          
        return {
          ...current,
          boundingBoxes: updatedBoxes,
          selectedBox: updatedSelectedBox,
          editingLabelId: null,
          editingLabelText: ""
        }
      }
      return current;
    })
  }, [])

  // Optimized interaction state methods
  const setDragState = useCallback((newState: Partial<AnnotationState['dragState']> | ((prev: AnnotationState['dragState']) => AnnotationState['dragState'])) => {
    const updatedState = typeof newState === 'function' 
      ? newState(dragStateRef.current)
      : { ...dragStateRef.current, ...newState }
    
    dragStateRef.current = updatedState
    
    // Only update React state if necessary
    if (updatedState.isDragging !== state.dragState.isDragging ||
        updatedState.originalBox !== state.dragState.originalBox) {
      setState(current => ({
        ...current,
        dragState: updatedState
      }))
    }
  }, [state.dragState.isDragging, state.dragState.originalBox])

  const setResizeState = useCallback((newState: Partial<AnnotationState['resizeState']> | ((prev: AnnotationState['resizeState']) => AnnotationState['resizeState'])) => {
    const updatedState = typeof newState === 'function'
      ? newState(resizeStateRef.current)
      : { ...resizeStateRef.current, ...newState }
    
    resizeStateRef.current = updatedState
    
    // Only update React state if necessary
    if (updatedState.isResizing !== state.resizeState.isResizing ||
        updatedState.handle !== state.resizeState.handle ||
        updatedState.originalBox !== state.resizeState.originalBox) {
      setState(current => ({
        ...current,
        resizeState: updatedState
      }))
    }
  }, [state.resizeState.isResizing, state.resizeState.handle, state.resizeState.originalBox])

  return {
    // Direct state access
    boundingBoxes: state.boundingBoxes,
    selectedBox: state.selectedBox,
    editingLabelId: state.editingLabelId,
    editingLabelText: state.editingLabelText,
    dragState: dragStateRef.current,
    resizeState: resizeStateRef.current,
    
    // Methods
    updateBox,
    selectBox,
    deleteBox,
    setEditingLabelId,
    setEditingLabelText,
    updateLabelAndFinishEditing,
    setDragState,
    setResizeState
  }
}

================
File: /Users/jess/Desktop/personal git/mobbin/formobbin/hooks/use-batch-management.ts
================
import { useState } from 'react';
import useSWR from 'swr';
import { API_ENDPOINTS, DEFAULT_BATCH_NAME_PREFIX } from '@/lib/constants';
import type { Batch } from '@/types/batch';

const fetcher = (url: string) => fetch(url).then(res => res.json());

export const useBatchManagement = () => {
  const [expandedBatchId, setExpandedBatchId] = useState<string | null>(null);
  const [showToast, setShowToast] = useState(false);
  
  const { data: batches, error, isLoading, mutate } = useSWR<Batch[]>(
    API_ENDPOINTS.BATCHES, 
    fetcher
  );

  const toggleBatch = (batchId: string) => {
    setExpandedBatchId(expandedBatchId === batchId ? null : batchId);
  };

  const generateDefaultBatchName = () => {
    const date = new Date();
    const day = String(date.getDate()).padStart(2, '0');
    const month = date.toLocaleString('default', { month: 'short' });
    const hour = String(date.getHours()).padStart(2, '0');
    const minute = String(date.getMinutes()).padStart(2, '0');
    return `${DEFAULT_BATCH_NAME_PREFIX}${day}${month}_${hour}${minute}`;
  };

  return {
    batches,
    error,
    isLoading,
    mutate,
    expandedBatchId,
    toggleBatch,
    showToast,
    setShowToast,
    generateDefaultBatchName,
  };
};

================
File: /Users/jess/Desktop/personal git/mobbin/formobbin/hooks/use-box-interaction.tsx
================
import { useCallback, useEffect, RefObject, useMemo, useState, useRef } from "react"
import { BoundingBox } from "@/types/annotation"


type DragState = {
  isDragging: boolean
  startX: number
  startY: number
  originalBox: BoundingBox | null
}

type ResizeState = {
  isResizing: boolean
  handle: string | null
  startX: number
  startY: number
  originalBox: BoundingBox | null
}

interface UseBoxInteractionProps {
  containerRef: RefObject<HTMLDivElement>
  scale: number
  updateBox: (box: BoundingBox) => void
  selectBox: (box: BoundingBox | null) => void
  setDragState: (state: Partial<DragState> | ((prev: DragState) => DragState)) => void
  setResizeState: (state: Partial<ResizeState> | ((prev: ResizeState) => ResizeState)) => void
}

export function useBoxInteraction({
  containerRef,
  scale,
  updateBox,
  selectBox,
  setDragState,
  setResizeState
}: UseBoxInteractionProps) {
  // Add throttling refs
  const lastUpdateTime = useRef(0)
  const THROTTLE_MS = 16 // ~60fps

  // Set up global mouse event listeners for dragging and resizing
  useEffect(() => {
    const handleMouseMove = (e: MouseEvent) => {
      const now = Date.now()
      if (now - lastUpdateTime.current < THROTTLE_MS) {
        return
      }
      lastUpdateTime.current = now

      if (containerRef.current) {
        const rect = containerRef.current.getBoundingClientRect()
        const x = (e.clientX - rect.left) / scale
        const y = (e.clientY - rect.top) / scale

        // Get current state using callback pattern
        setDragState(dragState => {
          // Handle dragging
          if (dragState.isDragging && dragState.originalBox) {
            const deltaX = x - dragState.startX / scale
            const deltaY = y - dragState.startY / scale

            const updatedBox = {
              ...dragState.originalBox,
              x: dragState.originalBox.x + deltaX,
              y: dragState.originalBox.y + deltaY,
            }

            // Batch the update
            requestAnimationFrame(() => {
              updateBox(updatedBox)
            })
          }
          return dragState;
        })

        // Get current resize state
        setResizeState((resizeState: ResizeState) => {
          // Handle resizing
          if (resizeState.isResizing && resizeState.originalBox && resizeState.handle) {
            const deltaX = x - resizeState.startX / scale
            const deltaY = y - resizeState.startY / scale
            const original = resizeState.originalBox
            let updatedBox = { ...original }

            // Apply resize based on which handle is being dragged
            switch (resizeState.handle) {
              case "top-left":
                updatedBox = {
                  ...original,
                  x: original.x + deltaX,
                  y: original.y + deltaY,
                  width: original.width - deltaX,
                  height: original.height - deltaY,
                }
                break
              case "top-right":
                updatedBox = {
                  ...original,
                  y: original.y + deltaY,
                  width: original.width + deltaX,
                  height: original.height - deltaY,
                }
                break
              case "bottom-left":
                updatedBox = {
                  ...original,
                  x: original.x + deltaX,
                  width: original.width - deltaX,
                  height: original.height + deltaY,
                }
                break
              case "bottom-right":
                updatedBox = {
                  ...original,
                  width: original.width + deltaX,
                  height: original.height + deltaY,
                }
                break
              case "top":
                updatedBox = {
                  ...original,
                  y: original.y + deltaY,
                  height: original.height - deltaY,
                }
                break
              case "right":
                updatedBox = {
                  ...original,
                  width: original.width + deltaX,
                }
                break
              case "bottom":
                updatedBox = {
                  ...original,
                  height: original.height + deltaY,
                }
                break
              case "left":
                updatedBox = {
                  ...original,
                  x: original.x + deltaX,
                  width: original.width - deltaX,
                }
                break
            }

            // Ensure width and height are positive
            if (updatedBox.width < 10) {
              updatedBox.width = 10
              if (["top-left", "bottom-left", "left"].includes(resizeState.handle)) {
                updatedBox.x = original.x + original.width - 10
              }
            }

            if (updatedBox.height < 10) {
              updatedBox.height = 10
              if (["top-left", "top-right", "top"].includes(resizeState.handle)) {
                updatedBox.y = original.y + original.height - 10
              }
            }

            // Batch the update
            requestAnimationFrame(() => {
              updateBox(updatedBox)
            })
          }
          return resizeState;
        })
      }
    }

    const handleMouseUp = () => {
      setDragState({
        isDragging: false,
        startX: 0,
        startY: 0,
        originalBox: null,
      })

      setResizeState({
        isResizing: false,
        handle: null,
        startX: 0,
        startY: 0,
        originalBox: null,
      })
    }

    window.addEventListener("mousemove", handleMouseMove)
    window.addEventListener("mouseup", handleMouseUp)
    window.addEventListener("touchend", handleMouseUp)

    return () => {
      window.removeEventListener("mousemove", handleMouseMove)
      window.removeEventListener("mouseup", handleMouseUp)
      window.removeEventListener("touchend", handleMouseUp)
    }
  }, [containerRef, scale, updateBox, setDragState, setResizeState])

  const startDragging = useCallback((e: React.MouseEvent | React.TouchEvent, box: BoundingBox) => {
    if (containerRef.current) {
      const rect = containerRef.current.getBoundingClientRect()

      let clientX, clientY
      if ("touches" in e) {
        // Touch event
        clientX = e.touches[0].clientX
        clientY = e.touches[0].clientY
      } else {
        // Mouse event
        clientX = e.clientX
        clientY = e.clientY
      }

      setDragState({
        isDragging: true,
        startX: clientX - rect.left,
        startY: clientY - rect.top,
        originalBox: box,
      })
      selectBox(box)
      e.stopPropagation()
    }
  }, [containerRef, selectBox, setDragState])

  const startResizing = useCallback((e: React.MouseEvent | React.TouchEvent, box: BoundingBox, handle: string) => {
    if (containerRef.current) {
      const rect = containerRef.current.getBoundingClientRect()

      let clientX, clientY
      if ("touches" in e) {
        // Touch event
        clientX = e.touches[0].clientX
        clientY = e.touches[0].clientY
      } else {
        // Mouse event
        clientX = e.clientX
        clientY = e.clientY
      }

      setResizeState({
        isResizing: true,
        handle,
        startX: clientX - rect.left,
        startY: clientY - rect.top,
        originalBox: box,
      })
      selectBox(box)
      e.stopPropagation()
    }
  }, [containerRef, selectBox, setResizeState])

  return {
    startDragging,
    startResizing
  }
}

export function useControlPanelState(
  boundingBoxes: BoundingBox[],
  externalEditingState?: {
    editingLabel: string;
    setEditingLabel: (label: string) => void;
  }
) {
  // Use external state if provided, otherwise create local state
  const [localEditingLabel, setLocalEditingLabel] = useState<string>("")
  const editingLabel = externalEditingState?.editingLabel ?? localEditingLabel
  const setEditingLabel = externalEditingState?.setEditingLabel ?? setLocalEditingLabel
  
  const [activeTab, setActiveTab] = useState<string>("elements")
  const [hoveredBoxId, setHoveredBoxId] = useState<number | null>(null)
  const [view, setView] = useState<"list" | "edit">("list")

  // Calculate total inference time
  const totalInferenceTime = useMemo(() => {
    return boundingBoxes.reduce((total, box) => total + box.inferenceTime, 0)
  }, [boundingBoxes])

  return {
    editingLabel,
    setEditingLabel,
    activeTab,
    setActiveTab,
    hoveredBoxId,
    setHoveredBoxId,
    view,
    setView,
    totalInferenceTime
  }
}

================
File: /Users/jess/Desktop/personal git/mobbin/formobbin/hooks/use-image-scale.tsx
================
import { useState, useEffect, RefObject, useRef } from "react"

export function useImageScale(
  imageUrl: string,
  containerRef: RefObject<HTMLDivElement>,
  imageRef: RefObject<HTMLImageElement>
) {
  const [scale, setScale] = useState<number>(1)
  const lastScaleRef = useRef(1)
  const resizeTimeoutRef = useRef<NodeJS.Timeout | undefined>(undefined)

  // Calculate scale factor when image loads or container resizes
  useEffect(() => {
    const updateScale = () => {
      if (imageRef.current && containerRef.current) {
        const containerWidth = containerRef.current.clientWidth
        const imageNaturalWidth = imageRef.current.naturalWidth

        if (imageNaturalWidth > containerWidth) {
          const newScale = containerWidth / imageNaturalWidth
          // Only update if the scale has changed significantly
          if (Math.abs(newScale - lastScaleRef.current) > 0.01) {
            lastScaleRef.current = newScale
            setScale(newScale)
          }
        } else if (lastScaleRef.current !== 1) {
          lastScaleRef.current = 1
          setScale(1)
        }
      }
    }

    // Debounced resize handler
    const handleResize = () => {
      if (resizeTimeoutRef.current) {
        clearTimeout(resizeTimeoutRef.current)
      }
      resizeTimeoutRef.current = setTimeout(updateScale, 100)
    }

    // Update scale when image loads
    if (imageRef.current) {
      imageRef.current.onload = updateScale
    }

    // Update scale on window resize with debounce
    window.addEventListener("resize", handleResize)
    return () => {
      window.removeEventListener("resize", handleResize)
      if (resizeTimeoutRef.current) {
        clearTimeout(resizeTimeoutRef.current)
      }
    }
  }, [imageUrl, containerRef, imageRef])

  return { scale }
}

================
File: /Users/jess/Desktop/personal git/mobbin/formobbin/hooks/use-mobile.tsx
================
"use client"

import { useEffect, useState } from "react"

export function useIsMobile() {
  const [isMobile, setIsMobile] = useState(false)

  useEffect(() => {
    const checkIfMobile = () => {
      setIsMobile(window.innerWidth < 768)
    }

    // Initial check
    checkIfMobile()

    // Add event listener
    window.addEventListener("resize", checkIfMobile)

    // Clean up
    return () => {
      window.removeEventListener("resize", checkIfMobile)
    }
  }, [])

  return isMobile
}

================
File: /Users/jess/Desktop/personal git/mobbin/formobbin/lib/constants.ts
================
export const MAX_FILES_PER_BATCH = 20;
export const DEFAULT_BATCH_NAME_PREFIX = 'Batch_';
export const API_ENDPOINTS = {
  BATCHES: '/api/batches',
  UPLOAD: '/api/upload',
} as const;

export const TOAST_MESSAGES = {
  UPLOAD_ERROR: 'Upload failed. Please try again.',
  LOADING_BATCHES: 'Loading batches, please wait...',
} as const;

================
File: /Users/jess/Desktop/personal git/mobbin/formobbin/lib/file-utils.ts
================
import { MAX_FILES_PER_BATCH } from './constants';

export const filterAndLimitImageFiles = (files: File[], existingFiles: File[] = []): File[] => {
  const imageFiles = files.filter((file) => file.type.startsWith('image/'));
  const limitedFiles = imageFiles.slice(0, MAX_FILES_PER_BATCH);
  const combinedFiles = [...existingFiles, ...limitedFiles].slice(0, MAX_FILES_PER_BATCH);
  return combinedFiles;
};

export const removeFileAtIndex = (files: File[], index: number): File[] => {
  const newFiles = [...files];
  newFiles.splice(index, 1);
  return newFiles;
};

================
File: /Users/jess/Desktop/personal git/mobbin/formobbin/lib/image-processor.ts
================
import sharp from 'sharp'
import fs from 'fs'
import path from 'path'
// import { v4 as uuidv4 } from 'uuid'

// Constants instead of magic numbers
const MAX_FILE_SIZE_MB = 1
const DEFAULT_TARGET_WIDTH = 800
const DEFAULT_TARGET_HEIGHT = 800
const DEFAULT_JPEG_QUALITY = 80

// Temporary directory for processed images
const TEMP_DIR = path.join(process.cwd(), 'tmp')

/**
 * Normalizes a filename by removing special characters and spaces
 * @param filename - Original filename to normalize
 * @returns Normalized filename with only alphanumeric characters, dots, and hyphens
 */
function sanitizeFilename(filename: string): string {
  // Remove file extension
  const { name, ext } = path.parse(filename)
  
  // Replace spaces and special characters with hyphens
  const normalized = name
    .toLowerCase()
    .replace(/[^a-z0-9]/g, '-') // Replace non-alphanumeric with hyphens
    .replace(/-+/g, '-')        // Replace multiple hyphens with single hyphen
    .replace(/^-|-$/g, '')      // Remove leading/trailing hyphens
  
  // Add timestamp to ensure uniqueness
  return `${normalized}${ext}`
}

// Ensure temp directory exists
if (!fs.existsSync(TEMP_DIR)) {
  fs.mkdirSync(TEMP_DIR, { recursive: true })
}

interface ProcessedImage {
  buffer: Buffer;
  filename: string;
}

/**
 * Compresses and pads an image to make it uniform in size
 * @param imageBuffer - The raw image buffer
 * @param originalFilename - Original filename to preserve
 * @param targetWidth - Desired width after processing
 * @param targetHeight - Desired height after processing
 * @returns Object containing the path and filename of the processed image
 */
export async function resizeAndPadImageBuffer(
  imageBuffer: Buffer,
  originalFilename: string,
  targetWidth: number = DEFAULT_TARGET_WIDTH,
  targetHeight: number = DEFAULT_TARGET_HEIGHT
): Promise<ProcessedImage> {
  const filename = sanitizeFilename(originalFilename)
  
  try {
    const metadata = await sharp(imageBuffer).metadata()
    
    // Calculate resize dimensions while maintaining aspect ratio
    let resizeWidth = targetWidth
    let resizeHeight = targetHeight
    
    if (metadata.width && metadata.height) {
      const aspectRatio = metadata.width / metadata.height
      
      if (aspectRatio > 1) {
        // Landscape image
        resizeHeight = Math.round(targetWidth / aspectRatio)
      } else {
        // Portrait image
        resizeWidth = Math.round(targetHeight * aspectRatio)
      }
    }
    
    // Process image and return buffer directly
    const processedBuffer = await sharp(imageBuffer)
      .resize(resizeWidth, resizeHeight, {
        fit: 'inside',
        withoutEnlargement: true
      })
      .jpeg({ quality: DEFAULT_JPEG_QUALITY }) // Compress to reduce file size
      .toBuffer()
      .then(resizedBuffer => {
        // Create a blank canvas with the target dimensions
        return sharp({
          create: {
            width: targetWidth,
            height: targetHeight,
            channels: 4,
            background: { r: 255, g: 255, b: 255, alpha: 1 }
          }
        })
        .composite([{
          input: resizedBuffer,
          gravity: 'center'
        }])
        .jpeg({ quality: DEFAULT_JPEG_QUALITY })
        .toBuffer()
      })

    return {
      buffer: processedBuffer,
      filename
    }
  } catch (error) {
    console.error('Error processing image:', error)
    throw error
  }
}

/**
 * Cleans up a temporary file
 */
export function deleteFile(filePath: string): void {
  try {
    if (fs.existsSync(filePath)) {
      fs.unlinkSync(filePath)
    }
  } catch (error) {
    console.error('Error cleaning up temp file:', error)
  }
}

================
File: /Users/jess/Desktop/personal git/mobbin/formobbin/lib/schema_v2.sql
================
-- Schema Version 2
-- Description: Database schema that works

-- Drop tables in dependency order
DROP TABLE IF EXISTS annotation_element CASCADE;
DROP TABLE IF EXISTS annotation_version CASCADE;
DROP TABLE IF EXISTS screenshot CASCADE;
DROP TABLE IF EXISTS batch CASCADE;
DROP TABLE IF EXISTS taxonomy CASCADE;

-- Taxonomy: shared label definitions for UI elements
CREATE TABLE taxonomy (
    taxonomy_id SERIAL PRIMARY KEY,
    taxonomy_label_name TEXT NOT NULL,       -- e.g., 'Button'
    taxonomy_description TEXT,               -- explanation/usage notes
    taxonomy_created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Batch: groups of uploaded screenshots with performance data
CREATE TABLE batch (
    batch_id SERIAL PRIMARY KEY,
    batch_name TEXT NOT NULL,             -- batch name from the UI
    batch_created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    batch_status TEXT NOT NULL CHECK (batch_status IN ('uploading', 'extracting', 'annotating', 'preview', 'done')),
    batch_analysis_type TEXT NOT NULL CHECK (batch_analysis_type IN ('Usability Audit', 'Conversion Analysis', 'UI Categorization')),
    batch_master_prompt_runtime NUMERIC,  -- in seconds
    batch_total_inference_time NUMERIC,   -- in seconds
    batch_detected_elements_count INTEGER, -- number of detected UI elements
    batch_description TEXT                -- optional metadata
);

-- Screenshot: individual UI images; file_url is generated by Supabase Storage
CREATE TABLE screenshot (
    screenshot_id SERIAL PRIMARY KEY,
    batch_id INTEGER REFERENCES batch(batch_id) ON DELETE CASCADE,
    screenshot_file_name TEXT NOT NULL,
    screenshot_file_url TEXT NOT NULL,         -- full public URL from Supabase Storage
    screenshot_processing_status TEXT NOT NULL CHECK (screenshot_processing_status IN ('pending', 'processing', 'completed', 'error')),
    screenshot_processing_time INTERVAL,       -- time taken to annotate this image
    screenshot_created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Annotation Version: versioning for screenshot annotations
CREATE TABLE annotation_version (
    annotation_version_id SERIAL PRIMARY KEY,
    screenshot_id INTEGER REFERENCES screenshot(screenshot_id) ON DELETE CASCADE,
    annotation_version_number INTEGER NOT NULL,  -- starts at 1 and increments
    annotation_version_created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    CONSTRAINT unique_version_per_screenshot UNIQUE (screenshot_id, annotation_version_number)
);

-- Annotation Element: details for each UI element annotation
CREATE TABLE annotation_element (
    annotation_element_id SERIAL PRIMARY KEY,
    annotation_version_id INTEGER REFERENCES annotation_version(annotation_version_id) ON DELETE CASCADE,
    annotation_element_x_min NUMERIC NOT NULL,             -- x-coordinate (top-left)
    annotation_element_x_max NUMERIC NOT NULL,             -- to get bounding box width
    annotation_element_y_min NUMERIC NOT NULL,             -- y-coordinate
    annotation_element_y_max NUMERIC NOT NULL,             -- to get bounding box height
    taxonomy_id INTEGER REFERENCES taxonomy(taxonomy_id),  -- shared label definition
    annotation_element_text_label TEXT,                -- display text (from UI)
    annotation_element_description TEXT,               -- additional element description
    annotation_element_inference_time NUMERIC NOT NULL -- detection time in seconds
);

-- Add indexes for common queries and foreign keys
CREATE INDEX idx_screenshot_batch ON screenshot(batch_id);
CREATE INDEX idx_annotation_version_screenshot ON annotation_version(screenshot_id);
CREATE INDEX idx_annotation_element_version ON annotation_element(annotation_version_id);
CREATE INDEX idx_annotation_element_taxonomy ON annotation_element(taxonomy_id);

================
File: /Users/jess/Desktop/personal git/mobbin/formobbin/lib/schema_v3.sql
================
-- Schema Version 3
-- Description: Database schema v3 (Removed annotation_element_versions, and added trigger)


-- Drop tables in dependency order
DROP TABLE IF EXISTS annotation_element CASCADE;
DROP TABLE IF EXISTS screenshot CASCADE;
DROP TABLE IF EXISTS batch CASCADE;
DROP TABLE IF EXISTS taxonomy CASCADE;

------------------------------------------------------------
-- Taxonomy: shared label definitions for UI elements
------------------------------------------------------------
CREATE TABLE taxonomy (
    taxonomy_id BIGSERIAL PRIMARY KEY,
    taxonomy_label_name TEXT NOT NULL,       -- e.g., 'Button'
    taxonomy_description TEXT,               -- explanation/usage notes
    taxonomy_created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

------------------------------------------------------------
-- Batch: groups of uploaded screenshots with performance data
------------------------------------------------------------
CREATE TABLE batch (
    batch_id BIGSERIAL PRIMARY KEY,
    batch_name TEXT NOT NULL,             -- batch name from the UI
    batch_created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    batch_status TEXT NOT NULL CHECK (batch_status IN ('uploading', 'extracting', 'annotating', 'preview', 'done')),
    batch_analysis_type TEXT NOT NULL CHECK (batch_analysis_type IN ('Usability Audit', 'Conversion Analysis', 'UI Categorization')),
    batch_master_prompt_runtime NUMERIC,   -- in seconds
    batch_total_inference_time NUMERIC,    -- in seconds
    batch_detected_elements_count INTEGER, -- number of detected UI elements
    batch_description TEXT                 -- optional metadata
);

------------------------------------------------------------
-- Screenshot: individual UI images; file_url is generated by Supabase Storage
------------------------------------------------------------
CREATE TABLE screenshot (
    screenshot_id BIGSERIAL PRIMARY KEY,
    batch_id BIGINT NOT NULL,  -- renamed to match v2 foreign key naming
    screenshot_file_name TEXT NOT NULL,
    screenshot_file_url TEXT NOT NULL,         -- full public URL from Supabase Storage
    screenshot_processing_status TEXT NOT NULL CHECK (screenshot_processing_status IN ('pending', 'processing', 'completed', 'error')),
    screenshot_processing_time INTERVAL,       -- time taken to annotate this image
    screenshot_created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    CONSTRAINT fk_screenshot_batch
        FOREIGN KEY (batch_id)
        REFERENCES batch(batch_id)
        ON DELETE CASCADE
);

-- Index for better join performance on batch_id
CREATE INDEX idx_screenshot_batch_id ON screenshot(batch_id);

------------------------------------------------------------
-- Annotation Element: details for each UI element annotation
-- Denormalized table containing annotation metadata (including integrated versioning)
------------------------------------------------------------
CREATE TABLE annotation_element (
    annotation_element_id BIGSERIAL PRIMARY KEY,
    screenshot_id BIGINT NOT NULL, -- renamed to match v2 foreign key naming (was annotation_element_screenshot_id)
    annotation_element_version_number INTEGER NOT NULL DEFAULT 1,  -- version number (default 1, incremented for revisions)
    annotation_element_created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    annotation_element_x_min NUMERIC NOT NULL,           -- x-coordinate (top-left)
    annotation_element_x_max NUMERIC NOT NULL,           -- for bounding box width
    annotation_element_y_min NUMERIC NOT NULL,           -- y-coordinate (top-left)
    annotation_element_y_max NUMERIC NOT NULL,           -- for bounding box height
    taxonomy_id BIGINT,               -- renamed to match v2 (was annotation_element_taxonomy_id)
    annotation_element_text_label TEXT,                  -- display text (from UI)
    annotation_element_description TEXT,                 -- additional element description
    annotation_element_inference_time NUMERIC NOT NULL,  -- detection time in seconds
    CONSTRAINT fk_annotation_element_screenshot
        FOREIGN KEY (screenshot_id)
        REFERENCES screenshot(screenshot_id)
        ON DELETE CASCADE,
    CONSTRAINT fk_annotation_element_taxonomy
        FOREIGN KEY (taxonomy_id)
        REFERENCES taxonomy(taxonomy_id)
        ON DELETE SET NULL
);

-- Indexes for efficient lookups on foreign keys
CREATE INDEX idx_annotation_element_screenshot_id ON annotation_element(screenshot_id);
CREATE INDEX idx_annotation_element_taxonomy_id ON annotation_element(taxonomy_id);

------------------------------------------------------------
-- Function and Trigger to Automatically Set version_number
------------------------------------------------------------
CREATE OR REPLACE FUNCTION set_annotation_version()
RETURNS TRIGGER AS $$
DECLARE
    current_max INTEGER;
BEGIN
    -- Only set version_number if it was not explicitly provided (or provided as 0)
    IF NEW.annotation_element_version_number IS NULL OR NEW.annotation_element_version_number = 0 THEN
        SELECT COALESCE(MAX(annotation_element_version_number), 0)
          INTO current_max
        FROM annotation_element
        WHERE screenshot_id = NEW.screenshot_id;
        NEW.annotation_element_version_number := current_max + 1;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_set_annotation_version
BEFORE INSERT ON annotation_element
FOR EACH ROW
EXECUTE FUNCTION set_annotation_version();

================
File: /Users/jess/Desktop/personal git/mobbin/formobbin/lib/storage.ts
================
import { createClient } from '@supabase/supabase-js';
import { supabase } from './supabase';
import fs from 'fs';

// Constants
// const DEFAULT_BUCKET_NAME = 'processed-images';
// const DEFAULT_BUCKET_NAME = 'screenshots';
const DEFAULT_BUCKET_NAME = 'screenshot';
const PUBLIC_FOLDER = 'public';

export interface UploadResult {
  fileUrl: string;
  error?: Error;
}

/**
 * Uploads a file from a local path to Supabase Storage
 * @param filePath - Path to the local file
 * @param fileName - Name to use for the uploaded file
 * @param bucketName - Supabase storage bucket name
 * @returns Public URL of the uploaded file or null if failed
 */
export async function uploadToSupabaseStorage(
  filePath: string,
  fileName: string,
  bucketName: string = DEFAULT_BUCKET_NAME
): Promise<string | null> {
  try {
    // Read the file
    const fileBuffer = fs.readFileSync(filePath);
    
    // Upload to Supabase
    const { data, error } = await supabase.storage
      .from(bucketName)
      .upload(`${PUBLIC_FOLDER}/${fileName}`, fileBuffer, {
        contentType: 'image/jpeg',
        upsert: true
      });
    
    if (error) {
      console.error('Error uploading to Supabase:', error);
      return null;
    }
    
    // Get public URL
    const { data: urlData } = supabase.storage
      .from(bucketName)
      .getPublicUrl(`${PUBLIC_FOLDER}/${fileName}`);
    
    return urlData.publicUrl;
  } catch (error) {
    console.error('Error in uploadToSupabaseStorage:', error);
    return null;
  }
}

/**
 * Generates a random 4-character alphabetic string
 */
function generateRandomSuffix(): string {
  const alphabet = 'AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz';
  let result = '';
  for (let i = 0; i < 4; i++) {
    result += alphabet.charAt(Math.floor(Math.random() * alphabet.length));
  }
  return result;
}

export async function uploadImageToStorage(
  file: File | Blob,
  batchId: number,
  filename: string
): Promise<UploadResult> {
  try {
    // Add random suffix to filename
    const fileExtension = filename.split('.').pop();
    const baseName = filename.substring(0, filename.lastIndexOf('.'));
    const randomSuffix = generateRandomSuffix();
    const newFilename = `${baseName}_${randomSuffix}.${fileExtension}`;
    
    const storagePath = `${DEFAULT_BUCKET_NAME}/${batchId}/${newFilename}`;
    
    const { data, error } = await supabase.storage
      .from(DEFAULT_BUCKET_NAME)
      .upload(storagePath, file, {
        cacheControl: '3600',
        upsert: false
      });

    if (error) throw error;

    const { data: { publicUrl } } = supabase.storage
      .from(DEFAULT_BUCKET_NAME)
      .getPublicUrl(storagePath);

    return { fileUrl: publicUrl };
  } catch (error) {
    console.error('Error uploading to storage:', error);
    return { fileUrl: '', error: error as Error };
  }
}

================
File: /Users/jess/Desktop/personal git/mobbin/formobbin/lib/supabase.ts
================
import { createClient } from '@supabase/supabase-js'

const supabaseUrl = process.env.SUPABASE_URL!
const supabaseKey = process.env.SUPABASE_ANON_KEY!
const serviceRoleKey = process.env.SUPABASE_SERVICE_KEY!

console.log("Supabase URL:", supabaseUrl)
console.log("Supabase Anon Key:", supabaseKey)
console.log("Supabase Service Role Key:", serviceRoleKey)

// Client with service role for server-side operations
export const supabase = createClient(supabaseUrl, serviceRoleKey)
// Client for client-side operations
export const supabaseClient = createClient(supabaseUrl, supabaseKey)

================
File: /Users/jess/Desktop/personal git/mobbin/formobbin/lib/utils.ts
================
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
