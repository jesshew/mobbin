This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-04-01T16:25:45.777Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
/
  Users/
    jess/
      Desktop/
        personal git/
          mobbin/
            formobbin/
              app/
                page.tsx
              components/
                annotation/
                  annotation-canvas.tsx
                  annotation-header.tsx
                  box-handles.tsx
                  label-editor.tsx
                control-panel/
                  control-panel-header.tsx
                  element-editor.tsx
                  element-list.tsx
                  panel-footer-actions.tsx
                  summary-panel.tsx
                upload/
                  batch-card.tsx
                  batch-list.tsx
                  dropzone-area.tsx
                  image-card.tsx
                  selected-images-panel.tsx
                annotation-editor.tsx
                control-panel.tsx
                element-list-item.tsx
                upload-interface.tsx
              hooks/
                use-annotation-state.tsx
                use-box-interaction.tsx
                use-image-scale.tsx
                use-mobile.tsx

================================================================
Repository Files
================================================================

================
File: /Users/jess/Desktop/personal git/mobbin/formobbin/app/page.tsx
================
"use client"

import { useState } from "react"
import { UploadInterface } from "@/components/upload-interface"
import { AnnotationEditor } from "@/components/annotation-editor"

// Define types for our batch management system
export interface Batch {
  id: string
  name: string
  timestamp: Date
  images: File[]
  status: "uploading" | "extracting" | "annotating" | "preview" | "done"
  analysisType: string
  performance?: {
    masterPromptRuntime: number // in seconds
    totalInferenceTime: number // in seconds
    detectedElementsCount: number
  }
}

export default function AnnotationTool() {
  // States for the streamlined flow
  const [selectedFiles, setSelectedFiles] = useState<File[]>([])
  const [batches, setBatches] = useState<Batch[]>([])
  const [selectedBatchId, setSelectedBatchId] = useState<string | null>(null)
  const [selectedImageIndex, setSelectedImageIndex] = useState<number | null>(null)
  const [currentView, setCurrentView] = useState<"upload" | "annotation">("upload")

  // Handle file selection (not uploading yet)
  const handleFilesSelected = (files: File[]) => {
    setSelectedFiles(files)
  }

  // Handle batch upload
  const handleUploadBatch = (batchName: string, analysisType: string) => {
    // In a real app, this would make API calls to upload files
    // For now, we'll just simulate the upload by creating a batch
    const newBatchId = Date.now().toString()

    // Create initial batch with 'uploading' status
    const newBatch: Batch = {
      id: newBatchId,
      name: batchName || `Batch ${batches.length + 1}`,
      timestamp: new Date(),
      images: [...selectedFiles],
      status: "uploading",
      analysisType: analysisType
    }

    setBatches([...batches, newBatch])
    setSelectedFiles([]) // Clear selected files after upload

    // Simulate status changes
    simulateBatchProcessing(newBatchId)
  }

  // Simulate batch processing with status changes
  const simulateBatchProcessing = (batchId: string) => {
    // Simulate upload completion after 2 seconds
    setTimeout(() => {
      setBatches((currentBatches) =>
        currentBatches.map((batch) => (batch.id === batchId ? { ...batch, status: "extracting" as const } : batch)),
      )

      // Simulate extraction completion after 3 more seconds
      setTimeout(() => {
        setBatches((currentBatches) =>
          currentBatches.map((batch) =>
            batch.id === batchId
              ? {
                  ...batch,
                  status: "preview" as const,
                  performance: {
                    masterPromptRuntime: 1.8 + Math.random() * 0.5,
                    totalInferenceTime: 5.2 + Math.random() * 2,
                    detectedElementsCount: Math.floor(5 + Math.random() * 10),
                  },
                }
              : batch,
          ),
        )
      }, 3000)
    }, 2000)
  }

  // Handle image selection from a batch
  const handleImageSelect = (batchId: string, imageIndex: number) => {
    setSelectedBatchId(batchId)
    setSelectedImageIndex(imageIndex)
    setCurrentView("annotation")

    // Update batch status to 'annotating' when user starts annotating
    setBatches((currentBatches) =>
      currentBatches.map((batch) =>
        batch.id === batchId && batch.status !== "done" ? { ...batch, status: "annotating" as const } : batch,
      ),
    )
  }

  // Handle navigation back to upload interface
  const handleBackToUpload = () => {
    // When returning from annotation, mark the batch as 'done'
    if (selectedBatchId) {
      setBatches((currentBatches) =>
        currentBatches.map((batch) => (batch.id === selectedBatchId ? { ...batch, status: "done" as const } : batch)),
      )
    }

    setSelectedBatchId(null)
    setSelectedImageIndex(null)
    setCurrentView("upload")
  }

  // Handle navigation between images in annotation view
  const handleNextImage = () => {
    const currentBatch = batches.find((batch) => batch.id === selectedBatchId)
    if (selectedImageIndex !== null && currentBatch && selectedImageIndex < currentBatch.images.length - 1) {
      setSelectedImageIndex(selectedImageIndex + 1)
    }
  }

  const handlePreviousImage = () => {
    if (selectedImageIndex !== null && selectedImageIndex > 0) {
      setSelectedImageIndex(selectedImageIndex - 1)
    }
  }

  // Render the appropriate view based on the current state
  return (
    <main className="min-h-screen bg-background">
      {currentView === "upload" && (
        <UploadInterface
          selectedFiles={selectedFiles}
          batches={batches}
          onFilesSelected={handleFilesSelected}
          onUploadBatch={handleUploadBatch}
          onImageSelect={handleImageSelect}
        />
      )}

      {currentView === "annotation" && selectedBatchId && selectedImageIndex !== null && (
        <AnnotationEditor
          image={batches.find((batch) => batch.id === selectedBatchId)!.images[selectedImageIndex]}
          onBack={handleBackToUpload}
          onNextImage={
            selectedImageIndex < batches.find((batch) => batch.id === selectedBatchId)!.images.length - 1
              ? handleNextImage
              : undefined
          }
          onPreviousImage={selectedImageIndex > 0 ? handlePreviousImage : undefined}
        />
      )}
    </main>
  )
}

================
File: /Users/jess/Desktop/personal git/mobbin/formobbin/components/annotation/annotation-canvas.tsx
================
import React from "react"
import { LabelEditor } from "./label-editor"
import { BoxHandles } from "./box-handles"
import { BoundingBox } from "@/types/annotation"

interface ImageState {
  imageUrl: string
  scale: number
  imageRef: React.RefObject<HTMLImageElement>
  containerRef: React.RefObject<HTMLDivElement>
}

interface BoxControls {
  boundingBoxes: BoundingBox[]
  selectedBox: BoundingBox | null
  onSelect: (box: BoundingBox) => void
  onUpdate: (box: BoundingBox) => void
  onDelete: (id: number) => void
  onDeselect: () => void
}

interface LabelEditing {
    editingLabelId: number | null
    editingLabelText: string
    setEditingLabelId: (id: number | null) => void
    setEditingLabelText: (text: string) => void
    updateLabelAndFinishEditing: () => void
  }

interface InteractionHandlers {
  startDragging: (e: React.MouseEvent | React.TouchEvent, box: BoundingBox) => void
  startResizing: (e: React.MouseEvent | React.TouchEvent, box: BoundingBox, handle: string) => void
  dragState: {
    isDragging: boolean
    startX: number
    startY: number
    originalBox: BoundingBox | null
  }
  resizeState: {
    isResizing: boolean
    handle: string | null
    startX: number
    startY: number
    originalBox: BoundingBox | null
  }
}

interface AnnotationCanvasProps {
  imageState: ImageState
  boxControls: BoxControls
  labelEditing: LabelEditing
  interactionHandlers: InteractionHandlers
  isMobile: boolean
}

export function AnnotationCanvas({
  imageState,
  boxControls,
  labelEditing,
  interactionHandlers,
  isMobile
}: AnnotationCanvasProps) {
  const { imageUrl, scale, imageRef, containerRef } = imageState
  const { boundingBoxes, selectedBox, onSelect, onUpdate } = boxControls
  const { editingLabelId, editingLabelText, setEditingLabelId, setEditingLabelText, updateLabelAndFinishEditing } = labelEditing
  const { startDragging, startResizing, dragState } = interactionHandlers

  const renderBoundingBox = (box: BoundingBox) => (
    <div
      key={box.id}
      className={`absolute border-2 ${
        selectedBox?.id === box.id ? "border-primary" : "border-blue-500"
      } bg-blue-500/10 group hover:bg-blue-500/20`}
      style={{
        left: `${box.x * scale}px`,
        top: `${box.y * scale}px`,
        width: `${box.width * scale}px`,
        height: `${box.height * scale}px`,
        cursor: dragState.isDragging && dragState.originalBox?.id === box.id ? "grabbing" : "grab",
      }}
      onClick={(e) => {
        e.stopPropagation()
        onSelect(box)
      }}
      onMouseDown={(e) => startDragging(e, box)}
      onTouchStart={(e) => startDragging(e, box)}
    >
      <LabelEditor
        box={box}
        editingLabelId={editingLabelId}
        editingLabelText={editingLabelText}
        setEditingLabelId={setEditingLabelId}
        setEditingLabelText={setEditingLabelText}
        updateLabelAndFinishEditing={updateLabelAndFinishEditing}
      />
      <BoxHandles 
        box={box} 
        startResizing={startResizing} 
        isMobile={isMobile} 
      />
    </div>
  )

  return (
    <div
      ref={containerRef}
      className="relative mx-auto bg-white shadow-md"
      style={{
        width: "100%",
        height: "90vh",
        overflow: "hidden",
      }}
    >
      {imageUrl && (
        <div className="relative h-full">
          <img
            ref={imageRef}
            src={imageUrl || "/placeholder.svg"}
            alt="Annotation canvas"
            className="w-full h-full object-contain"
            style={{
              width: "100%",
              height: "100%",
            }}
          />
          <div 
            className="absolute top-0 left-0 w-full h-full"
            style={{
              transform: `scale(${scale})`,
              transformOrigin: "top left",
            }}
          >
            {boundingBoxes.map(renderBoundingBox)}
          </div>
        </div>
      )}
    </div>
  )
}

================
File: /Users/jess/Desktop/personal git/mobbin/formobbin/components/annotation/annotation-header.tsx
================
import { ArrowLeft, Save } from "lucide-react"
import { Button } from "@/components/ui/button"

interface AnnotationHeaderProps {
  imageName: string
  onBack: () => void
  onSave: () => void
}

export function AnnotationHeader({ imageName, onBack, onSave }: AnnotationHeaderProps) {
  return (
    <div className="bg-background p-4 border-b flex items-center justify-between">
      <Button variant="ghost" onClick={onBack}>
        <ArrowLeft className="mr-2 h-4 w-4" />
        <span className="hidden sm:inline">Back to Upload</span>
        <span className="sm:hidden">Back</span>
      </Button>
      <h2 className="text-xl font-medium truncate max-w-[150px] sm:max-w-none">{imageName}</h2>
      <Button onClick={onSave} className="hidden md:flex">
        <Save className="mr-2 h-4 w-4" />
        Save
      </Button>
    </div>
  )
}

================
File: /Users/jess/Desktop/personal git/mobbin/formobbin/components/annotation/box-handles.tsx
================
import React from "react"
import { BoundingBox } from "@/types/annotation"

interface BoxHandlesProps {
  box: BoundingBox
  startResizing: (e: React.MouseEvent | React.TouchEvent, box: BoundingBox, handle: string) => void
  isMobile: boolean
}


export function BoxHandles({ box, startResizing, isMobile }: BoxHandlesProps) {
  const handleSize = isMobile ? "16px" : "12px"
  
  const handleConfigs = [
    // Corner handles
    { position: "top-0 left-0", translate: "-translate-x-1/2 -translate-y-1/2", cursor: "nwse-resize", handle: "top-left" },
    { position: "top-0 right-0", translate: "translate-x-1/2 -translate-y-1/2", cursor: "nesw-resize", handle: "top-right" },
    { position: "bottom-0 left-0", translate: "-translate-x-1/2 translate-y-1/2", cursor: "nesw-resize", handle: "bottom-left" },
    { position: "bottom-0 right-0", translate: "translate-x-1/2 translate-y-1/2", cursor: "nwse-resize", handle: "bottom-right" },
    // Edge handles
    { position: "top-0 left-1/2", translate: "-translate-x-1/2 -translate-y-1/2", cursor: "ns-resize", handle: "top" },
    { position: "right-0 top-1/2", translate: "translate-x-1/2 -translate-y-1/2", cursor: "ew-resize", handle: "right" },
    { position: "bottom-0 left-1/2", translate: "-translate-x-1/2 translate-y-1/2", cursor: "ns-resize", handle: "bottom" },
    { position: "left-0 top-1/2", translate: "-translate-x-1/2 -translate-y-1/2", cursor: "ew-resize", handle: "left" }
  ]

  return (
    <>
      {handleConfigs.map((config) => (
        <div
          key={config.handle}
          className={`absolute ${config.position} bg-primary rounded-full ${config.translate} cursor-${config.cursor} opacity-0 group-hover:opacity-100 transition-opacity`}
          onMouseDown={(e) => startResizing(e, box, config.handle)}
          onTouchStart={(e) => startResizing(e, box, config.handle)}
          style={{ width: handleSize, height: handleSize }}
        />
      ))}
    </>
  )
}

================
File: /Users/jess/Desktop/personal git/mobbin/formobbin/components/annotation/label-editor.tsx
================
import React from "react"
import { BoundingBox } from "@/types/annotation"

interface LabelEditorProps {
  box: BoundingBox
  editingLabelId: number | null
  editingLabelText: string
  setEditingLabelId: (id: number | null) => void
  setEditingLabelText: (text: string) => void
  updateLabelAndFinishEditing: () => void
}

export function LabelEditor({
  box,
  editingLabelId,
  editingLabelText,
  setEditingLabelId,
  setEditingLabelText,
  updateLabelAndFinishEditing
}: LabelEditorProps) {
  const handleKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {
    if (e.key === "Enter") {
      updateLabelAndFinishEditing()
    } else if (e.key === "Escape") {
      setEditingLabelId(null)
    }
  }

  const handleMouseEnter = () => {
    if (editingLabelId !== box.id) {
      setEditingLabelId(box.id)
    }
  }

  const labelStyles = "bg-blue-500 text-white text-xs px-1 py-0.5 rounded"

  return (
    <div
      className="absolute -top-6 left-0 min-w-[60px] max-w-full"
      onMouseEnter={handleMouseEnter}
    >
      {editingLabelId === box.id ? (
        <input
          type="text"
          value={editingLabelText}
          onChange={(e) => setEditingLabelText(e.target.value)}
          onBlur={updateLabelAndFinishEditing}
          onKeyDown={handleKeyDown}
          className={`${labelStyles} w-full outline-none border border-white`}
          autoFocus
          onClick={(e) => e.stopPropagation()}
        />
      ) : (
        <span className={`${labelStyles} pointer-events-auto cursor-text inline-block max-w-[200px] overflow-hidden text-ellipsis whitespace-nowrap`}>
          {box.textLabel}
        </span>
      )}
    </div>
  )
}

================
File: /Users/jess/Desktop/personal git/mobbin/formobbin/components/control-panel/control-panel-header.tsx
================
import { Clock } from "lucide-react"

interface ControlPanelHeaderProps {
  title: string
  masterPromptRuntime: number
  totalInferenceTime: number
}

export function ControlPanelHeader({ 
  title, 
  masterPromptRuntime, 
  totalInferenceTime 
}: ControlPanelHeaderProps) {
  return (
    <div className="p-4 border-b">
      <h3 className="text-lg font-medium">{title}</h3>
      <div className="mt-2 space-y-2">
        <div className="flex items-center justify-between">
          <div className="flex items-center text-sm">
            <Clock className="h-4 w-4 mr-1.5 text-muted-foreground" />
            <span>Master Prompt Runtime:</span>
          </div>
          <span className="font-medium">{masterPromptRuntime.toFixed(1)}s</span>
        </div>
        <div className="flex items-center justify-between">
          <div className="flex items-center text-sm">
            <Clock className="h-4 w-4 mr-1.5 text-muted-foreground" />
            <span>Total Inference Time:</span>
          </div>
          <span className="font-medium">{totalInferenceTime.toFixed(1)}s</span>
        </div>
      </div>
    </div>
  )
}

================
File: /Users/jess/Desktop/personal git/mobbin/formobbin/components/control-panel/element-editor.tsx
================
import { ArrowLeft, List, WandSparkles, Trash2 } from "lucide-react"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { ScrollArea } from "@/components/ui/scroll-area"
import { BoundingBox } from "@/types/annotation"

interface ElementEditorProps {
  selectedBox: BoundingBox
  onBoxUpdate: (box: BoundingBox) => void
  onBoxDelete: (id: number) => void
  onBackToList: () => void
  editingLabel?: string
  setEditingLabel?: (label: string) => void
}

export function ElementEditor({
  selectedBox,
  onBoxUpdate,
  onBoxDelete,
  onBackToList,
  editingLabel,
  setEditingLabel
}: ElementEditorProps) {
  // Use shared state when available, fallback to local state
//   const currentEditingLabel = editingLabel ?? selectedBox.textLabel;
  const handleEditingLabelChange = setEditingLabel ?? ((value: string) => {
    onBoxUpdate({ ...selectedBox, textLabel: value })
  });

  const handleLabelChange = (value: string) => {
    onBoxUpdate({ ...selectedBox, label: value })
  }

  const handleTextLabelChange = (value: string) => {
    onBoxUpdate({ ...selectedBox, textLabel: value })
    handleEditingLabelChange(value)
  }

  const handleDescriptionChange = (value: string) => {
    onBoxUpdate({ ...selectedBox, description: value })
  }

  const handleCoordinateChange = (field: keyof BoundingBox, value: string) => {
    const numValue = Number.parseInt(value, 10)
    if (!isNaN(numValue)) {
      onBoxUpdate({ ...selectedBox, [field]: numValue })
    }
  }

  return (
    <>
      <div className="p-4 border-b">
        <div className="flex items-center justify-between mb-2">
          <h3 className="text-lg font-medium">Edit Element</h3>
          <Button variant="ghost" size="sm" onClick={onBackToList}>
            <ArrowLeft className="h-4 w-4 mr-1" />
            {/* <List className="h-4 w-4 mr-1" /> */}
            Back to Element List
          </Button>
        </div>
        <p className="text-sm text-muted-foreground">
          {`Editing "${selectedBox.textLabel}" (${selectedBox.label})`}
        </p>
      </div>

      <ScrollArea className={"flex-1"}>
        <div className="p-4 space-y-4">
          <div className="space-y-2">
            <Label htmlFor="element-type">Element Type</Label>
            <Select value={selectedBox.label} onValueChange={handleLabelChange}>
              <SelectTrigger id="element-type">
                <SelectValue placeholder="Select element type" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="Button">Button</SelectItem>
                <SelectItem value="Tab Bar">Tab Bar</SelectItem>
                <SelectItem value="Text Field">Text Field</SelectItem>
                <SelectItem value="Checkbox">Checkbox</SelectItem>
                <SelectItem value="Dropdown">Dropdown</SelectItem>
                <SelectItem value="Image">Image</SelectItem>
                <SelectItem value="Icon">Icon</SelectItem>
                <SelectItem value="Label">Label</SelectItem>
              </SelectContent>
            </Select>
          </div>

          <div className="space-y-2">
            <Label htmlFor="text-label">Text Label</Label>
            <Input
              id="text-label"
              value={selectedBox.textLabel}
              onChange={(e) => handleTextLabelChange(e.target.value)}
              placeholder="Enter display text"
            />
          </div>

          <div className="space-y-2">
            <Label htmlFor="description">Description</Label>
            <Input
              id="description"
              value={selectedBox.description}
              onChange={(e) => handleDescriptionChange(e.target.value)}
              placeholder="Enter description"
            />
          </div>

          <div className="space-y-2">
            <Label htmlFor="inference-time">Inference Time</Label>
            <Input
              id="inference-time"
              value={`${selectedBox.inferenceTime.toFixed(2)}s`}
              readOnly
              disabled
              className="bg-muted"
            />
          </div>

          <div className="grid grid-cols-2 gap-2">
            <div className="space-y-2">
              <Label htmlFor="x-coord">X Position</Label>
              <Input
                id="x-coord"
                type="number"
                value={selectedBox.x}
                onChange={(e) => handleCoordinateChange("x", e.target.value)}
              />
            </div>
            <div className="space-y-2">
              <Label htmlFor="y-coord">Y Position</Label>
              <Input
                id="y-coord"
                type="number"
                value={selectedBox.y}
                onChange={(e) => handleCoordinateChange("y", e.target.value)}
              />
            </div>
            <div className="space-y-2">
              <Label htmlFor="width">Width</Label>
              <Input
                id="width"
                type="number"
                value={selectedBox.width}
                onChange={(e) => handleCoordinateChange("width", e.target.value)}
              />
            </div>
            <div className="space-y-2">
              <Label htmlFor="height">Height</Label>
              <Input
                id="height"
                type="number"
                value={selectedBox.height}
                onChange={(e) => handleCoordinateChange("height", e.target.value)}
              />
            </div>
          </div>
        </div>
      </ScrollArea>

      <div className="border-t p-4">
        {/* <Button className="w-full mb-3" variant="outline" onClick={() => onBoxDelete(selectedBox.id)}>
          <Trash2 className="mr-2 h-4 w-4" />
          Delete Element
        </Button> */}
        <Button className="w-full mb-3" variant="outline">
          <WandSparkles className="mr-2 h-4 w-4" />
          Regenerate Description and Label
        </Button>
        <Button className="w-full" onClick={onBackToList}>
          <ArrowLeft className="mr-2 h-4 w-4" />
          Back to Element List
        </Button>
      </div>
    </>
  )
}

================
File: /Users/jess/Desktop/personal git/mobbin/formobbin/components/control-panel/element-list.tsx
================
import { Trash2, Eye, Clock } from "lucide-react"
import { Button } from "@/components/ui/button"
import { ScrollArea } from "@/components/ui/scroll-area"
import { BoundingBox } from "@/types/annotation"
import { RevealOnHover } from "@/components/ui/reveal-on-hover"

interface ElementListProps {
  boundingBoxes: BoundingBox[]
  selectedBox: BoundingBox | null
  hoveredBoxId: number | null
  setHoveredBoxId: (id: number | null) => void
  onBoxSelect: (box: BoundingBox) => void
  onBoxDelete: (id: number) => void
  // isMobile: boolean
  // setActiveTab?: (tab: string) => void
}

export function ElementList({
  boundingBoxes,
  selectedBox,
  hoveredBoxId,
  setHoveredBoxId,
  onBoxSelect,
  onBoxDelete,
  // isMobile,
  // setActiveTab
}: ElementListProps) {
  const handleElementSelect = (box: BoundingBox) => {
    onBoxSelect(box)
    // if (isMobile && setActiveTab) {
    //   setActiveTab("editor")
    // }
  }

  const getBorderClass = (box: BoundingBox) => {
    // if (isMobile) {
    //   return selectedBox?.id === box.id ? "border-primary" : "border-border"
    // }
    return hoveredBoxId === box.id ? "border-primary/50" : "border-border"
  }

  const renderBoxDetails = (box: BoundingBox) => (
    <RevealOnHover isVisible={hoveredBoxId === box.id}>
      <div className="text-xs text-muted-foreground">{box.label}</div>
      <div className="text-xs text-muted-foreground mt-1">
        x: {box.x}, y: {box.y}, w: {box.width}, h: {box.height}
      </div>
      <div className="text-xs flex items-center mt-1 text-muted-foreground">
        <Clock className="h-3 w-3 mr-1" />
        Inference Time: {box.inferenceTime.toFixed(2)}s
      </div>
    </RevealOnHover>
  )

  const renderActionButtons = (box: BoundingBox) => (
    <div className="flex gap-1 ml-2">
      <Button
        variant="ghost"
        size="icon"
        className="h-7 w-7"
        onClick={(e) => {
          e.stopPropagation()
          handleElementSelect(box)
        }}
      >
        <Eye className="h-4 w-4" />
      </Button>
      <Button
        variant="ghost"
        size="icon"
        className="h-7 w-7 text-destructive"
        onClick={(e) => {
          e.stopPropagation()
          onBoxDelete(box.id)
        }}
      >
        <Trash2 className="h-4 w-4" />
      </Button>
    </div>
  )

  return (
    <ScrollArea className="flex-1">
      <div className="p-4 space-y-2">
        {boundingBoxes.map((box) => (
          <div
            key={box.id}
            className={`rounded-md border transition-all duration-200 overflow-hidden ${getBorderClass(box)}`}
            onMouseEnter={() => setHoveredBoxId(box.id)}
            onMouseLeave={() => setHoveredBoxId(null)}
            onClick={() => handleElementSelect(box)}
          >
            <div className="p-3">
              <div className="flex items-center justify-between">
                <div className="font-medium truncate">{box.textLabel}</div>
                {hoveredBoxId === box.id && renderActionButtons(box)}
              </div>

              {renderBoxDetails(box)}
            </div>
          </div>
        ))}
      </div>
    </ScrollArea>
  )
}

================
File: /Users/jess/Desktop/personal git/mobbin/formobbin/components/control-panel/panel-footer-actions.tsx
================
import { ArrowLeft, ArrowRight, Save, Download } from "lucide-react"
import { Button } from "@/components/ui/button"

interface PanelFooterActionsProps {
  onSave: () => void
  onExport: () => void
  onPreviousImage?: () => void
  onNextImage?: () => void
}

export function PanelFooterActions({
  onSave,
  onExport,
  onPreviousImage,
  onNextImage
}: PanelFooterActionsProps) {
  return (
    <div className="border-t p-4">
      <div className="grid grid-cols-2 gap-2 mb-3">
        <Button variant="outline" className="w-full" onClick={onPreviousImage} disabled={!onPreviousImage}>
          <ArrowLeft className="mr-2 h-4 w-4" />
          {onPreviousImage ? "Previous" : "Prev Image"}
        </Button>
        <Button variant="outline" className="w-full" onClick={onNextImage} disabled={!onNextImage}>
          {onNextImage ? "Next" : "Next Image"}
          <ArrowRight className="ml-2 h-4 w-4" />
        </Button>
      </div>
      <Button className="w-full mb-2" onClick={onSave}>
        <Save className="mr-2 h-4 w-4" />
        Save Changes
      </Button>
      <Button className="w-full" variant="secondary" onClick={onExport}>
        <Download className="mr-2 h-4 w-4" />
        Export Annotations
      </Button>
    </div>
  )
}

================
File: /Users/jess/Desktop/personal git/mobbin/formobbin/components/control-panel/summary-panel.tsx
================
import { Clock } from "lucide-react"
import { ScrollArea } from "@/components/ui/scroll-area"
import { Separator } from "@/components/ui/separator"

interface SummaryPanelProps {
  masterPromptRuntime: number
  totalInferenceTime: number
  elementCount: number
}

export function SummaryPanel({ masterPromptRuntime, totalInferenceTime, elementCount }: SummaryPanelProps) {
  const averageInferenceTime = elementCount > 0 ? totalInferenceTime / elementCount : 0

  return (
    <ScrollArea className="h-[calc(100vh-220px)]">
      <div className="p-4 space-y-4">
        <div className="space-y-2">
          <h3 className="text-lg font-medium">Performance Summary</h3>
          <div className="mt-2 space-y-2">
            <div className="flex items-center justify-between">
              <div className="flex items-center text-sm">
                <Clock className="h-4 w-4 mr-1.5 text-muted-foreground" />
                <span>Master Prompt Runtime:</span>
              </div>
              <span className="font-medium">{masterPromptRuntime.toFixed(1)}s</span>
            </div>
            <div className="flex items-center justify-between">
              <div className="flex items-center text-sm">
                <Clock className="h-4 w-4 mr-1.5 text-muted-foreground" />
                <span>Total Inference Time:</span>
              </div>
              <span className="font-medium">{totalInferenceTime.toFixed(1)}s</span>
            </div>
          </div>
        </div>

        <Separator />

        <div className="space-y-2">
          <h3 className="text-lg font-medium">Element Statistics</h3>
          <div className="text-sm">
            <p>Total Elements: {elementCount}</p>
            <p>Average Inference Time: {averageInferenceTime.toFixed(2)}s</p>
          </div>
        </div>
      </div>
    </ScrollArea>
  )
}

================
File: /Users/jess/Desktop/personal git/mobbin/formobbin/components/upload/batch-card.tsx
================
import { 
  Calendar, 
  FileImage, 
  ChevronUp, 
  ChevronDown, 
  BarChart,
  Loader2,
  Zap,
  Pencil,
  Eye,
  CheckCircle,
  ClipboardCheck
} from "lucide-react"
import { Button } from "@/components/ui/button"
import { Badge } from "@/components/ui/badge"
import { Separator } from "@/components/ui/separator"
import { ScrollArea } from "@/components/ui/scroll-area"
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip"
import { ImageCard } from "./image-card"
import type { Batch } from "@/app/page"

interface BatchCardProps {
  batch: Batch
  isExpanded: boolean
  onToggle: () => void
  onImageSelect: (imageIndex: number) => void

}

export function BatchCard({ batch, isExpanded, onToggle, onImageSelect }: BatchCardProps) {
  // Format date for display
  const formatDate = (date: Date) => {
    return new Intl.DateTimeFormat("en-US", {
      year: "numeric",
      month: "short",
      day: "numeric",
      hour: "2-digit",
      minute: "2-digit",
    }).format(date)
  }

  // Define status badge configurations
  const STATUS_BADGE_CONFIG: Record<Batch["status"], {
    icon: React.ReactNode;
    label: string;
    className: string;
  }> = {
    uploading: {
      icon: <Loader2 className="h-3 w-3 animate-spin" />,
      label: "Uploading",
      className: "bg-blue-50 text-blue-700 border-blue-200"
    },
    extracting: {
      icon: <Zap className="h-3 w-3" />,
      label: "Extracting UI",
      className: "bg-amber-50 text-amber-700 border-amber-200"
    },
    annotating: {
      icon: <Pencil className="h-3 w-3" />,
      label: "Annotating",
      className: "bg-purple-50 text-purple-700 border-purple-200"
    },
    preview: {
      icon: <Eye className="h-3 w-3" />,
      label: "Preview Available",
      className: "bg-green-50 text-green-700 border-green-200"
    },
    done: {
      icon: <CheckCircle className="h-3 w-3" />,
      label: "Done",
      className: "bg-green-100 text-green-800 border-green-300"
    }
  };

  // Get status badge for a batch
  const getStatusBadge = (status: Batch["status"]) => {
    const config = STATUS_BADGE_CONFIG[status];
    if (!config) return null;

    return (
      <Badge variant="outline" className={`${config.className} flex items-center gap-1`}>
        {config.icon}
        <span>{config.label}</span>
      </Badge>
    );
  }

  const renderPerformanceTooltip = () => (
    <div className="flex items-center ml-4">
      <TooltipProvider>
        <Tooltip>
          <TooltipTrigger asChild>
            <Button variant="ghost" size="icon" className="flex items-center gap-1">
              <BarChart className="h-4 w-4 text-muted-foreground" />
              <span>Insight</span>

            </Button>
          </TooltipTrigger>
          <TooltipContent>
            <div className="text-xs">
              <p>Master Prompt: {batch.performance?.masterPromptRuntime.toFixed(1)}s</p>
              <p>Total Inference: {batch.performance?.totalInferenceTime.toFixed(1)}s</p>
              <p>Elements: {batch.performance?.detectedElementsCount}</p>
            </div>
          </TooltipContent>
        </Tooltip>
      </TooltipProvider>
    </div>
  )

  const renderBatchHeader = () => (
    <div className="flex-1">
      <div className="flex items-center justify-between mb-1">
        <h3 className="font-medium">{batch.name}</h3>
        {getStatusBadge(batch.status)}
      </div>
      <div className="flex flex-wrap items-center text-sm text-muted-foreground mt-1">
        <div className="flex items-center gap-2 mr-4">
          <Calendar className="h-4 w-4" />
          {formatDate(batch.timestamp)}
        </div>
        <div className="flex items-center gap-2 mr-4">
          <FileImage className="h-4 w-4" />
          {batch.images.length} {batch.images.length === 1 ? "image" : "images"}
        </div>
        {batch.analysisType && (
          <div className="flex items-center gap-2 mr-4">
            <ClipboardCheck className="h-4 w-4" />
            <span>{batch.analysisType}</span>
          </div>
        )}
        {batch.performance && renderPerformanceTooltip()}
      </div>
    </div>
  )

  const renderPerformanceStats = () => (
    <div className="px-4 py-2 bg-muted/30 border-t border-b">
      <div className="grid grid-cols-3 gap-2 text-sm">
        <div className="flex flex-col items-center p-2 rounded-md bg-background">
          <span className="text-muted-foreground text-xs">Master Prompt</span>
          <span className="font-medium">{batch.performance?.masterPromptRuntime.toFixed(1)}s</span>
        </div>
        <div className="flex flex-col items-center p-2 rounded-md bg-background">
          <span className="text-muted-foreground text-xs">Inference Time</span>
          <span className="font-medium">{batch.performance?.totalInferenceTime.toFixed(1)}s</span>
        </div>
        <div className="flex flex-col items-center p-2 rounded-md bg-background">
          <span className="text-muted-foreground text-xs">Elements</span>
          <span className="font-medium">{batch.performance?.detectedElementsCount}</span>
        </div>
      </div>
    </div>
  )

  const renderImageGrid = () => (
    <div className="p-4">
      <ScrollArea className="h-[300px]">
        <div className="grid grid-cols-1 xs:grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-4">
          {batch.images.map((file, index) => (
            <ImageCard
              key={`${file.name}-${index}`}
              file={file}
              index={index}
              onClick={() => onImageSelect(index)}
            />
          ))}
        </div>
      </ScrollArea>
    </div>
  )

  return (
    <div className="rounded-md border border-border overflow-hidden">
      <div
        className="p-4 flex items-center justify-between cursor-pointer hover:bg-muted/50 transition-colors"
        onClick={onToggle}
      >
        {renderBatchHeader()}
        <Button variant="ghost" size="icon" className="ml-2">
          {isExpanded ? (
            <ChevronUp className="h-5 w-5" />
          ) : (
            <ChevronDown className="h-5 w-5" />
          )}
        </Button>
      </div>

      {batch.performance && isExpanded && renderPerformanceStats()}

      {isExpanded && (
        <>
          <Separator />
          {renderImageGrid()}
        </>
      )}
    </div>
  )
}

================
File: /Users/jess/Desktop/personal git/mobbin/formobbin/components/upload/batch-list.tsx
================
import type { Batch } from "@/app/page"
import { BatchCard } from "@/components/upload/batch-card"
// import { RevealOnHover } from "@/components/ui/reveal-on-hover"

interface BatchListProps {
  batches: Batch[]
  expandedBatchId: string | null
  toggleBatch: (batchId: string) => void
  onImageSelect: (batchId: string, imageIndex: number) => void
}

export function BatchList({ 
  batches, 
  expandedBatchId, 
  toggleBatch, 
  onImageSelect,
}: BatchListProps) {
  return (
    <div className="mt-4">
      <h2 className="text-xl font-medium mb-4">Batches ({batches.length})</h2>
      <div className="space-y-3">
        {batches.map((batch) => (
        //   <div
        //     key={batch.id}
        //     className={`transition-all duration-300 ease-in-out group ${
        //       expandedBatchId === batch.id 
        //         ? 'max-h-[500px] opacity-100' 
        //         : 'max-h-[80px] opacity-90 hover:opacity-100'
        //     }`}
        //     onMouseEnter={() => toggleBatch(batch.id)}
        //     onMouseLeave={() => toggleBatch(batch.id)}
        //   >
            <BatchCard
              key={batch.id}
              batch={batch}
              isExpanded={expandedBatchId === batch.id}
              onToggle={() => toggleBatch(batch.id)}
              onImageSelect={(imageIndex: number) => onImageSelect(batch.id, imageIndex)}
            />
        //   </div>
        ))}
      </div>
    </div>
  )
}

================
File: /Users/jess/Desktop/personal git/mobbin/formobbin/components/upload/dropzone-area.tsx
================
import { useDropzone } from "react-dropzone"
import { Upload, ImageIcon, FolderOpen } from "lucide-react"
import { Button } from "@/components/ui/button"

interface DropzoneAreaProps {
  isDragging: boolean
  setIsDragging: (isDragging: boolean) => void
  onDrop: (acceptedFiles: File[]) => void
}

export function DropzoneArea({ isDragging, setIsDragging, onDrop }: DropzoneAreaProps) {
  const { getRootProps, getInputProps } = useDropzone({
    onDrop,
    accept: {
      "image/*": [],
    },
    onDragEnter: () => setIsDragging(true),
    onDragLeave: () => setIsDragging(false),
  })

  return (
    <div
      {...getRootProps()}
      className={`border-2 border-dashed rounded-lg p-6 md:p-10 text-center cursor-pointer transition-colors
        ${isDragging ? "border-primary bg-primary/5" : "border-muted-foreground/25 hover:border-primary/50"}`}
    >
      <input {...getInputProps()} />
      <Upload className="mx-auto h-10 w-10 md:h-12 md:w-12 text-muted-foreground mb-4" />
      <h2 className="text-lg md:text-xl font-medium mb-2">Drag & drop images here</h2>
      <p className="text-muted-foreground mb-4">Or click to browse files (up to 20 images)</p>
      <div className="flex flex-col sm:flex-row justify-center gap-3">
        <Button className="w-full sm:w-auto">
          <ImageIcon className="mr-2 h-4 w-4" />
          Select Images
        </Button>
        <Button variant="outline" className="w-full sm:w-auto">
          <FolderOpen className="mr-2 h-4 w-4" />
          Select Folder
        </Button>
      </div>
    </div>
  )
}

================
File: /Users/jess/Desktop/personal git/mobbin/formobbin/components/upload/image-card.tsx
================
import { Button } from "@/components/ui/button"
import { Card, CardContent } from "@/components/ui/card"
import { X } from "lucide-react"
import Image from "next/image"

interface ImageCardProps {
  file: File
  index: number
  onRemove?: (index: number) => void
  onClick?: () => void
  showRemoveButton?: boolean
}

export function ImageCard({ 
  file, 
  index, 
  onRemove, 
  onClick, 
  showRemoveButton = false 
}: ImageCardProps) {
  const imageUrl = URL.createObjectURL(file) || "/placeholder.svg"
  const isClickable = Boolean(onClick)
  
  const cardClassName = `relative group ${
    isClickable ? 'cursor-pointer hover:shadow-md transition-shadow' : ''
  }`

  const handleRemoveClick = (e: React.MouseEvent) => {
    e.stopPropagation()
    onRemove?.(index)
  }

  return (
    <Card 
      className={cardClassName}
      onClick={onClick}
    >
      <CardContent className="p-2">
        <div className="aspect-square relative overflow-hidden rounded-md mb-2">
          <Image
            src={imageUrl}
            alt={file.name}
            fill
            className="object-cover"
          />
          {showRemoveButton && onRemove && (
            <Button
              variant="destructive"
              size="icon"
              className="absolute top-1 right-1 h-6 w-6 opacity-0 group-hover:opacity-100 transition-opacity"
              onClick={handleRemoveClick}
            >
              <X className="h-3 w-3" />
            </Button>
          )}
        </div>
        <p className="text-xs break-words">{file.name}</p>
      </CardContent>
    </Card>
  )
}

================
File: /Users/jess/Desktop/personal git/mobbin/formobbin/components/upload/selected-images-panel.tsx
================
import { Upload } from "lucide-react"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { ScrollArea } from "@/components/ui/scroll-area"
import { ImageCard } from "./image-card"
import { 
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue 
} from "@/components/ui/select"
import { Toast, ToastProvider, ToastViewport, ToastTitle, ToastDescription } from "@/components/ui/toast"
import React from "react"

// Define analysis types as constants to avoid magic strings
const ANALYSIS_TYPES = {
    USABILITY: 'Usability Audit',
    MARKETING: 'Conversion Analysis',
    // ACCESSIBILITY: 'Inclusive Design Audit',
    TAXONOMY: 'UI Categorization'
  }  

interface SelectedImagesPanelProps {
  selectedFiles: File[]
  batchName: string
  setBatchName: (name: string) => void
  onRemoveFile: (index: number) => void
  onUploadBatch: (batchName: string, analysisType: string) => void
  analysisType: string
  setAnalysisType: (type: string) => void
}

export function SelectedImagesPanel({
  selectedFiles,
  batchName,
  setBatchName,
  onRemoveFile,
  onUploadBatch,
  analysisType,
  setAnalysisType,
}: SelectedImagesPanelProps) {
  const [showToast, setShowToast] = React.useState(false);

  const handleUpload = () => {
    if (!analysisType) {
      setShowToast(true);
      return;
    }
    
    onUploadBatch(batchName, analysisType);
  };

  return (
    <ToastProvider>
      <div>
        <div className="flex flex-col sm:flex-row justify-between items-start sm:items-center mb-4">
          <h2 className="text-xl font-medium">Selected Images ({selectedFiles.length})</h2>
          <div className="flex flex-col sm:flex-row gap-3 mt-2 sm:mt-0 w-full sm:w-auto">
            <div className="flex-1 sm:flex-initial">
              <Input
                placeholder="Batch Name (optional)"
                value={batchName}
                onChange={(e) => setBatchName(e.target.value)}
                className="w-full"
              />
            </div>
            
            <Select 
              value={analysisType} 
              onValueChange={(value) => setAnalysisType(value)}
            >
              <SelectTrigger className="w-full sm:w-[220px]">
                <SelectValue placeholder="Select Analysis Type" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value={ANALYSIS_TYPES.USABILITY}>
                  {ANALYSIS_TYPES.USABILITY}
                </SelectItem>
                <SelectItem value={ANALYSIS_TYPES.MARKETING}>
                  {ANALYSIS_TYPES.MARKETING}
                </SelectItem>
                {/* <SelectItem value={ANALYSIS_TYPES.ACCESSIBILITY}>
                  {ANALYSIS_TYPES.ACCESSIBILITY}
                </SelectItem> */}
                <SelectItem value={ANALYSIS_TYPES.TAXONOMY}>
                  {ANALYSIS_TYPES.TAXONOMY}
                </SelectItem>
              </SelectContent>
            </Select>
            
            <Button className="w-full sm:w-auto" onClick={handleUpload}>
              <Upload className="mr-2 h-4 w-4" />
              Upload Batch
            </Button>
          </div>
        </div>

        <ScrollArea className="h-[300px] md:h-[400px] rounded-md border">
          <div className="grid grid-cols-1 xs:grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-4 p-4">
            {selectedFiles.map((file, index) => (
              <ImageCard
                key={`${file.name}-${index}`}
                file={file}
                index={index}
                onRemove={onRemoveFile}
                showRemoveButton
              />
            ))}
          </div>
        </ScrollArea>
      </div>
      
      {showToast && (
        <Toast variant="default" onOpenChange={setShowToast}>
          <ToastTitle>Analysis type required</ToastTitle>
          <ToastDescription>
            Please select an analysis type before uploading.
          </ToastDescription>
        </Toast>
      )}
      
      <ToastViewport />
    </ToastProvider>
  )
}

================
File: /Users/jess/Desktop/personal git/mobbin/formobbin/components/annotation-editor.tsx
================
"use client"

import type React from "react"

import { useState, useRef, useEffect } from "react"
import { ArrowLeft, Save, ChevronUp, ChevronDown } from "lucide-react"
import { Button } from "@/components/ui/button"
import { ControlPanel } from "@/components/control-panel"
import { useIsMobile } from "@/hooks/use-mobile"
import { useImageScale } from "../hooks/use-image-scale"
import { useBoxInteraction } from "../hooks/use-box-interaction"
import { AnnotationCanvas } from "../components/annotation/annotation-canvas"
import { AnnotationHeader } from "../components/annotation/annotation-header"
import { BoundingBox } from "@/types/annotation"
import { useAnnotationState } from "../hooks/use-annotation-state"

// Mock data for demonstration purposes
const mockBoundingBoxes = [
  {
    id: 1,
    label: "Button",
    textLabel: "Submit",
    description: "Main action button",
    x: 50,
    y: 100,
    width: 120,
    height: 40,
    inferenceTime: 0.78,
  },
  {
    id: 2,
    label: "Tab Bar",
    textLabel: "Navigation",
    description: "Main navigation tabs",
    x: 200,
    y: 50,
    width: 300,
    height: 60,
    inferenceTime: 1.25,
  },
  {
    id: 3,
    label: "Text Field",
    textLabel: "Username",
    description: "Username input field",
    x: 100,
    y: 200,
    width: 200,
    height: 40,
    inferenceTime: 0.92,
  },
  {
    id: 4,
    label: "Checkbox",
    textLabel: "Remember me",
    description: "Session persistence option",
    x: 400,
    y: 300,
    width: 30,
    height: 30,
    inferenceTime: 0.65,
  },
  {
    id: 5,
    label: "Dropdown",
    textLabel: "Country",
    description: "Country selection dropdown",
    x: 500,
    y: 150,
    width: 150,
    height: 40,
    inferenceTime: 1.12,
  },
]


interface AnnotationEditorProps {
  image: File
  onBack: () => void
  onNextImage?: () => void
  onPreviousImage?: () => void
}

export function AnnotationEditor({ image, onBack, onNextImage, onPreviousImage }: AnnotationEditorProps) {
  // Use our centralized annotation state
  const {
    boundingBoxes,
    selectedBox,
    editingLabelId,
    editingLabelText,
    setEditingLabelId,
    setEditingLabelText,
    updateBox,
    selectBox,
    deleteBox,
    updateLabelAndFinishEditing,
    dragState,
    resizeState,
    setDragState,
    setResizeState
  } = useAnnotationState(mockBoundingBoxes)

  const [masterPromptRuntime, setMasterPromptRuntime] = useState<number>(1.8) // in seconds
  const [isPanelCollapsed, setIsPanelCollapsed] = useState(false)
  // const isMobile = useIsMobile()  // Commented out mobile check
  
  const containerRef = useRef<HTMLDivElement>(document.createElement('div'))
  const imageRef = useRef<HTMLImageElement>(document.createElement('img'))
  
  // Custom hooks
  const { imageUrl, scale } = useImageScale(image, containerRef, imageRef)
  
  // Use the useBoxInteraction hook with our centralized state
  const { startDragging, startResizing } = useBoxInteraction({
    containerRef,
    scale,
    updateBox,
    selectBox,
    setDragState,
    setResizeState
  })

  const handleSave = () => {
    console.log("Saving annotation data:", boundingBoxes)
    // Here you would typically send the data to your backend
    alert("Annotations saved successfully!")
  }

  const togglePanel = () => {
    setIsPanelCollapsed(!isPanelCollapsed)
  }

  // Group related props
  const boxControls = {
    boundingBoxes,
    selectedBox,
    onSelect: selectBox,
    onUpdate: updateBox,
    onDelete: deleteBox,
    onDeselect: () => selectBox(null)
  }

  const labelEditing = {
    editingLabelId,
    editingLabelText,
    setEditingLabelId,
    setEditingLabelText,
    updateLabelAndFinishEditing
  }

  const imageState = {
    imageUrl,
    scale,
    imageRef,
    containerRef
  }

  const interactionHandlers = {
    startDragging,
    startResizing,
    dragState,
    resizeState
  }

  return (
    <div className="flex h-screen min-w-[800px]">
      {/* Main annotation area - fixed width and height */}
      <div className="w-[1000px] h-screen flex flex-col">
        <AnnotationHeader 
          imageName={image.name}
          onBack={onBack}
          onSave={handleSave}
        />

        <div className="flex-1 overflow-auto bg-muted/30 p-2 sm:p-4">
          <AnnotationCanvas
            imageState={imageState}
            boxControls={boxControls}
            labelEditing={labelEditing}
            interactionHandlers={interactionHandlers}
            isMobile={false}
          />
        </div>

        {/* Mobile panel toggle button - commented out
        {isMobile && (
          <div className="border-t border-b p-2 bg-background flex justify-center">
            <Button variant="outline" onClick={togglePanel} className="w-full flex items-center justify-center">
              {isPanelCollapsed ? (
                <>
                  <ChevronUp className="mr-2 h-4 w-4" />
                  Show Control Panel
                </>
              ) : (
                <>
                  <ChevronDown className="mr-2 h-4 w-4" />
                  Hide Control Panel
                </>
              )}
            </Button>
          </div>
        )}
        */}
      </div>

      {/* Control panel / sidebar - flexible width */}
      <div className={`flex-1 border-l bg-background flex flex-col h-full min-w-[300px] ${isPanelCollapsed ? "hidden" : "flex"}`}>
        <ControlPanel
          boundingBoxes={boundingBoxes}
          selectedBox={selectedBox}
          onBoxSelect={selectBox}
          onBoxUpdate={updateBox}
          onBoxDelete={deleteBox}
          onBoxDeselect={() => selectBox(null)}
          editingLabelState={{
            editingLabelId,
            editingLabelText,
            setEditingLabelId,
            setEditingLabelText,
            updateLabelAndFinishEditing
          }}
          masterPromptRuntime={masterPromptRuntime}
          onSave={handleSave}
          onNextImage={onNextImage}
          onPreviousImage={onPreviousImage}
          isMobile={false}
        />
      </div>
    </div>
  )
}

================
File: /Users/jess/Desktop/personal git/mobbin/formobbin/components/control-panel.tsx
================
"use client"

import { useState } from "react"
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs"
import { ControlPanelHeader } from "@/components/control-panel/control-panel-header"
import { ElementList } from "@/components/control-panel/element-list"
import { ElementEditor } from "@/components/control-panel/element-editor"
import { SummaryPanel } from "@/components/control-panel/summary-panel"
import { PanelFooterActions } from "@/components/control-panel/panel-footer-actions"
import { BoundingBox } from "@/types/annotation"

interface ControlPanelProps {
  boundingBoxes: BoundingBox[]
  selectedBox: BoundingBox | null
  onBoxSelect: (box: BoundingBox) => void
  onBoxUpdate: (box: BoundingBox) => void
  onBoxDelete: (id: number) => void
  masterPromptRuntime: number
  onSave: () => void
  onNextImage?: () => void
  onPreviousImage?: () => void
  isMobile?: boolean
  onBoxDeselect: () => void
  editingLabelState: {
    editingLabelId: number | null
    editingLabelText: string
    setEditingLabelId: (id: number | null) => void
    setEditingLabelText: (text: string) => void
    updateLabelAndFinishEditing: () => void
  }
}

export function ControlPanel({
  boundingBoxes,
  selectedBox,
  onBoxSelect,
  onBoxUpdate,
  onBoxDelete,
  masterPromptRuntime,
  onSave,
  onNextImage,
  onPreviousImage,
  isMobile = false,
  onBoxDeselect,
  editingLabelState,
}: ControlPanelProps) {
  // Local UI state
  const [activeTab, setActiveTab] = useState<string>("elements")
  const [hoveredBoxId, setHoveredBoxId] = useState<number | null>(null)
  const [view, setView] = useState<"list" | "edit">("list")
  
  // Calculate total inference time
  const totalInferenceTime = boundingBoxes.reduce((total, box) => total + box.inferenceTime, 0)

  const handleElementSelect = (box: BoundingBox) => {
    onBoxSelect(box)
    setView("edit")
  }

  const handleBackToList = () => {
    onBoxDeselect()
    setView("list")
  }

  const handleExportAnnotations = () => {
    const annotationData = {
      masterPromptRuntime,
      totalInferenceTime,
      elements: boundingBoxes,
    }

    const dataStr = JSON.stringify(annotationData, null, 2)
    const dataUri = "data:application/json;charset=utf-8," + encodeURIComponent(dataStr)

    const exportFileDefaultName = "annotations.json"

    const linkElement = document.createElement("a")
    linkElement.setAttribute("href", dataUri)
    linkElement.setAttribute("download", exportFileDefaultName)
    linkElement.click()
  }

  // Mobile view uses tabs
  if (isMobile) {
    return (
      <div className="flex flex-col h-full">
        <Tabs defaultValue="elements" value={activeTab} onValueChange={setActiveTab} className="w-full">
          <div className="px-4 pt-4 border-b sticky top-0 bg-background z-10">
            <TabsList className="w-full grid grid-cols-3">
              <TabsTrigger value="elements">Elements</TabsTrigger>
              <TabsTrigger value="editor">Editor</TabsTrigger>
              <TabsTrigger value="summary">Summary</TabsTrigger>
            </TabsList>
          </div>

          <TabsContent value="elements" className="mt-0 p-0">
            <ElementList
              boundingBoxes={boundingBoxes}
              selectedBox={selectedBox}
              hoveredBoxId={hoveredBoxId}
              setHoveredBoxId={setHoveredBoxId}
              onBoxSelect={onBoxSelect}
              onBoxDelete={onBoxDelete}
            />
          </TabsContent>

          <TabsContent value="editor" className="mt-0 p-0">
            {selectedBox ? (
              <ElementEditor
                selectedBox={selectedBox}
                onBoxUpdate={onBoxUpdate}
                onBoxDelete={onBoxDelete}
                onBackToList={handleBackToList}
                editingLabel={editingLabelState.editingLabelText}
                setEditingLabel={editingLabelState.setEditingLabelText}
              />
            ) : (
              <div className="p-4 text-center text-muted-foreground">Select an element to edit its properties</div>
            )}
          </TabsContent>

          <TabsContent value="summary" className="mt-0 p-0">
            <SummaryPanel
              masterPromptRuntime={masterPromptRuntime}
              totalInferenceTime={totalInferenceTime}
              elementCount={boundingBoxes.length}
            />
          </TabsContent>
        </Tabs>

        <PanelFooterActions
          onSave={onSave}
          onExport={handleExportAnnotations}
          onPreviousImage={onPreviousImage}
          onNextImage={onNextImage}
        />
      </div>
    )
  }

  // Desktop view - now with separate list and edit views
  return (
    <div className="flex flex-col h-full">
      {/* List View */}
      {view === "list" && (
        <>
          <ControlPanelHeader
            title="Performance Summary"
            masterPromptRuntime={masterPromptRuntime}
            totalInferenceTime={totalInferenceTime}
          />

          <div className="p-4 border-b">
            <h3 className="text-lg font-medium">Detected Elements</h3>
            <p className="text-sm text-muted-foreground">{boundingBoxes.length} elements found</p>
          </div>

          <ElementList
            boundingBoxes={boundingBoxes}
            selectedBox={selectedBox}
            hoveredBoxId={hoveredBoxId}
            setHoveredBoxId={setHoveredBoxId}
            onBoxSelect={handleElementSelect}
            onBoxDelete={onBoxDelete}
          />

          <PanelFooterActions
            onSave={onSave}
            onExport={handleExportAnnotations}
            onPreviousImage={onPreviousImage}
            onNextImage={onNextImage}
          />
        </>
      )}

      {/* Edit View */}
      {view === "edit" && selectedBox && (
        <ElementEditor
          selectedBox={selectedBox}
          onBoxUpdate={onBoxUpdate}
          onBoxDelete={onBoxDelete}
          onBackToList={handleBackToList}
          editingLabel={editingLabelState.editingLabelText}
          setEditingLabel={editingLabelState.setEditingLabelText}
        />
      )}
    </div>
  )
}

================
File: /Users/jess/Desktop/personal git/mobbin/formobbin/components/element-list-item.tsx
================
"use client"
import { motion, AnimatePresence } from "framer-motion"
import { Trash2, Eye, Clock, ChevronDown, ChevronUp } from "lucide-react"
import { Button } from "@/components/ui/button"
import { Card, CardContent } from "@/components/ui/card"
import { BoundingBox } from "@/types/annotation"

interface ElementListItemProps {
  box: BoundingBox
  isSelected: boolean
  isExpanded: boolean
  onSelect: (box: BoundingBox) => void
  onDelete: (id: number) => void
  onToggleExpand: (id: number) => void
  isMobile: boolean
}

export function ElementListItem({
  box,
  isSelected,
  isExpanded,
  onSelect,
  onDelete,
  onToggleExpand,
  isMobile,
}: ElementListItemProps) {
  const handleClick = () => {
    if (isMobile) {
      onSelect(box)
    } else {
      onToggleExpand(box.id)
    }
  }

  return (
    <Card className={`cursor-pointer transition-colors ${isSelected ? "border-primary" : ""}`} onClick={handleClick}>
      <CardContent className="p-3">
        <div className="flex items-center justify-between">
          <div className="max-w-[70%]">
            <div className="font-medium break-words">{box.textLabel}</div>
          </div>
          <div className="flex gap-1">
            {!isMobile && (
              <Button
                variant="ghost"
                size="icon"
                className="h-7 w-7"
                onClick={(e) => {
                  e.stopPropagation()
                  onToggleExpand(box.id)
                }}
              >
                {isExpanded ? <ChevronUp className="h-4 w-4" /> : <ChevronDown className="h-4 w-4" />}
              </Button>
            )}
          </div>
        </div>

        <AnimatePresence>
          {isExpanded && (
            <motion.div
              initial={{ height: 0, opacity: 0 }}
              animate={{ height: "auto", opacity: 1 }}
              exit={{ height: 0, opacity: 0 }}
              transition={{ duration: 0.2 }}
              className="overflow-hidden"
            >
              <div className="mt-2 pt-2 border-t">
                <div className="text-xs text-muted-foreground">
                  <span className="font-medium">Type:</span> {box.label}
                </div>
                <div
                  className="text-xs text-muted-foreground mt-1"
                  key={`${box.x}-${box.y}-${box.width}-${box.height}`}
                >
                  <span className="font-medium">Position:</span> x: {box.x}, y: {box.y}, w: {box.width}, h: {box.height}
                </div>
                <div className="text-xs flex items-center mt-1 text-muted-foreground">
                  <Clock className="h-3 w-3 mr-1" />
                  Inference Time: {box.inferenceTime.toFixed(2)}s
                </div>
                <div className="flex gap-1 mt-2">
                  <Button
                    variant="outline"
                    size="sm"
                    className="h-7 text-xs flex-1"
                    onClick={(e) => {
                      e.stopPropagation()
                      onSelect(box)
                    }}
                  >
                    <Eye className="h-3 w-3 mr-1" />
                    Edit
                  </Button>
                  <Button
                    variant="outline"
                    size="sm"
                    className="h-7 text-xs flex-1 text-destructive hover:text-destructive"
                    onClick={(e) => {
                      e.stopPropagation()
                      onDelete(box.id)
                    }}
                  >
                    <Trash2 className="h-3 w-3 mr-1" />
                    Delete
                  </Button>
                </div>
              </div>
            </motion.div>
          )}
        </AnimatePresence>
      </CardContent>
    </Card>
  )
}

================
File: /Users/jess/Desktop/personal git/mobbin/formobbin/components/upload-interface.tsx
================
"use client"

import { useState, useCallback } from "react"
import { Upload } from "lucide-react"
import type { Batch } from "@/app/page"
import { useIsMobile } from "@/hooks/use-mobile"
import { DropzoneArea } from "@/components/upload/dropzone-area"
import { SelectedImagesPanel } from "@/components/upload/selected-images-panel"
import { BatchList } from "@/components/upload/batch-list"

interface UploadInterfaceProps {
  selectedFiles: File[]
  batches: Batch[]
  onFilesSelected: (files: File[]) => void
  onUploadBatch: (batchName: string, analysisType: string) => void
  onImageSelect: (batchId: string, imageIndex: number) => void
}

export function UploadInterface({
  selectedFiles,
  batches,
  onFilesSelected,
  onUploadBatch,
  onImageSelect,
}: UploadInterfaceProps) {
  const [isDragging, setIsDragging] = useState(false)
  const [batchName, setBatchName] = useState("")
  const [expandedBatchId, setExpandedBatchId] = useState<string | null>(null)
  const isMobile = useIsMobile()
  const [analysisType, setAnalysisType] = useState("")
  const [showToast, setShowToast] = useState(false)

  const onDrop = useCallback(
    (acceptedFiles: File[]) => {
      // Filter to only include image files
      const imageFiles = acceptedFiles.filter((file) => file.type.startsWith("image/"))

      // Limit to 20 files
      const limitedFiles = imageFiles.slice(0, 20)

      // Combine with existing selected files, up to 20 total
      const combinedFiles = [...selectedFiles, ...limitedFiles].slice(0, 20)

      onFilesSelected(combinedFiles)
      setIsDragging(false)
    },
    [onFilesSelected, selectedFiles],
  )

  const removeFile = (index: number) => {
    const newFiles = [...selectedFiles]
    newFiles.splice(index, 1)
    onFilesSelected(newFiles)
  }

  const toggleBatch = (batchId: string) => {
    setExpandedBatchId(expandedBatchId === batchId ? null : batchId)
  }

  // const handleUploadBatch = (batchName: string, analysisType: string) => {
  //   console.log("handleUploadBatch", batchName, analysisType)
  //   const newBatchId = Date.now().toString()

  //   // Create initial batch with 'uploading' status
  //   const newBatch: Batch = {
  //     id: newBatchId,
  //     name: batchName || `Batch ${batches.length + 1}`,
  //     timestamp: new Date(),
  //     images: [...selectedFiles],
  //     status: "uploading",
  //     analysisType: analysisType // Add analysis type to batch
  //   }

  //   onFilesSelected([...selectedFiles, ...newBatch.images])
  //   setIsDragging(false)
  //   setBatchName(newBatch.name)
  //   setAnalysisType(analysisType)

  //   // Simulate status changes
  //   onUploadBatch(newBatch.name, analysisType)
  // }

  return (
    <div className="container mx-auto py-6 md:py-10 px-4">
      <h1 className="text-2xl md:text-3xl font-bold mb-6 md:mb-8 text-center">Annotation Tool</h1>

      <div className="flex flex-col gap-8">
        <DropzoneArea 
          isDragging={isDragging}
          setIsDragging={setIsDragging}
          onDrop={onDrop}
        />

        {selectedFiles.length > 0 && (
          <SelectedImagesPanel
            selectedFiles={selectedFiles}
            batchName={batchName}
            setBatchName={setBatchName}
            onRemoveFile={removeFile}
            onUploadBatch={(batchName, analysisType) => onUploadBatch(batchName, analysisType)}
            analysisType={analysisType}
            setAnalysisType={setAnalysisType}
          />
        )}

        {batches.length > 0 && (
          <BatchList
            batches={batches}
            expandedBatchId={expandedBatchId}
            toggleBatch={toggleBatch}
            onImageSelect={onImageSelect}
          />
        )}
      </div>
    </div>
  )
}

================
File: /Users/jess/Desktop/personal git/mobbin/formobbin/hooks/use-annotation-state.tsx
================
import { useState, useCallback } from "react"
import { BoundingBox } from "@/types/annotation"

interface AnnotationState {
  boundingBoxes: BoundingBox[]
  selectedBox: BoundingBox | null
  editingLabelId: number | null
  editingLabelText: string
  dragState: {
    isDragging: boolean
    startX: number
    startY: number
    originalBox: BoundingBox | null
  }
  resizeState: {
    isResizing: boolean
    handle: string | null
    startX: number
    startY: number
    originalBox: BoundingBox | null
  }
}

export function useAnnotationState(initialBoxes: BoundingBox[]) {
  // Core state management
  const [state, setState] = useState<AnnotationState>({
    boundingBoxes: initialBoxes,
    selectedBox: null,
    editingLabelId: null,
    editingLabelText: "",
    dragState: {
      isDragging: false,
      startX: 0,
      startY: 0,
      originalBox: null
    },
    resizeState: {
      isResizing: false,
      handle: null,
      startX: 0,
      startY: 0,
      originalBox: null
    }
  })

  // Box manipulation methods
  const updateBox = useCallback((updatedBox: BoundingBox) => {
    setState(current => ({
      ...current,
      boundingBoxes: current.boundingBoxes.map(box => 
        box.id === updatedBox.id ? updatedBox : box
      ),
      selectedBox: current.selectedBox?.id === updatedBox.id ? updatedBox : current.selectedBox
    }))
  }, [])

  const selectBox = useCallback((box: BoundingBox | null) => {
    setState(current => ({
      ...current,
      selectedBox: box
    }))
  }, [])

  const deleteBox = useCallback((id: number) => {
    setState(current => ({
      ...current,
      boundingBoxes: current.boundingBoxes.filter(box => box.id !== id),
      selectedBox: current.selectedBox?.id === id ? null : current.selectedBox,
      editingLabelId: current.editingLabelId === id ? null : current.editingLabelId
    }))
  }, [])

  // Label editing methods
  const setEditingLabelId = useCallback((id: number | null) => {
    setState(current => {
      // If starting to edit, pre-populate with the existing label
      const editingBox = id ? current.boundingBoxes.find(box => box.id === id) : null;
      
      return {
        ...current,
        editingLabelId: id,
        editingLabelText: editingBox ? editingBox.textLabel : current.editingLabelText
      }
    })
  }, [])

  const setEditingLabelText = useCallback((text: string) => {
    setState(current => ({
      ...current,
      editingLabelText: text
    }))
  }, [])

  const updateLabelAndFinishEditing = useCallback(() => {
    setState(current => {
      if (current.editingLabelId) {
        const updatedBoxes = current.boundingBoxes.map(box => 
          box.id === current.editingLabelId 
            ? { ...box, textLabel: current.editingLabelText } 
            : box
        );
        
        const updatedSelectedBox = current.selectedBox?.id === current.editingLabelId 
          ? { ...current.selectedBox, textLabel: current.editingLabelText } 
          : current.selectedBox;
          
        return {
          ...current,
          boundingBoxes: updatedBoxes,
          selectedBox: updatedSelectedBox,
          editingLabelId: null
        }
      }
      return current;
    })
  }, [])

  // Interaction state methods
  const setDragState = useCallback((state: Partial<AnnotationState['dragState']> | ((prev: AnnotationState['dragState']) => AnnotationState['dragState'])) => {
    setState(current => ({
      ...current,
      dragState: typeof state === 'function' 
        ? state(current.dragState)
        : { ...current.dragState, ...state }
    }))
  }, [])

  const setResizeState = useCallback((state: Partial<AnnotationState['resizeState']> | ((prev: AnnotationState['resizeState']) => AnnotationState['resizeState'])) => {
    setState(current => ({
      ...current,
      resizeState: typeof state === 'function'
        ? state(current.resizeState)
        : { ...current.resizeState, ...state }
    }))
  }, [])

  return {
    // Direct state access
    boundingBoxes: state.boundingBoxes,
    selectedBox: state.selectedBox,
    editingLabelId: state.editingLabelId,
    editingLabelText: state.editingLabelText,
    dragState: state.dragState,
    resizeState: state.resizeState,
    
    // Methods
    updateBox,
    selectBox,
    deleteBox,
    setEditingLabelId,
    setEditingLabelText,
    updateLabelAndFinishEditing,
    setDragState,
    setResizeState
  }
}

================
File: /Users/jess/Desktop/personal git/mobbin/formobbin/hooks/use-box-interaction.tsx
================
import { useCallback, useEffect, RefObject, useMemo, useState } from "react"
import { BoundingBox } from "@/types/annotation"


type DragState = {
  isDragging: boolean
  startX: number
  startY: number
  originalBox: BoundingBox | null
}

type ResizeState = {
  isResizing: boolean
  handle: string | null
  startX: number
  startY: number
  originalBox: BoundingBox | null
}

interface UseBoxInteractionProps {
  containerRef: RefObject<HTMLDivElement>
  scale: number
  updateBox: (box: BoundingBox) => void
  selectBox: (box: BoundingBox | null) => void
  setDragState: (state: Partial<DragState> | ((prev: DragState) => DragState)) => void
  setResizeState: (state: Partial<ResizeState> | ((prev: ResizeState) => ResizeState)) => void
}

export function useBoxInteraction({
  containerRef,
  scale,
  updateBox,
  selectBox,
  setDragState,
  setResizeState
}: UseBoxInteractionProps) {
  // Set up global mouse event listeners for dragging and resizing
  useEffect(() => {
    const handleMouseMove = (e: MouseEvent) => {
      if (containerRef.current) {
        const rect = containerRef.current.getBoundingClientRect()
        const x = (e.clientX - rect.left) / scale
        const y = (e.clientY - rect.top) / scale

        // Get current state using callback pattern
        setDragState(dragState => {
          // Handle dragging
          if (dragState.isDragging && dragState.originalBox) {
            const deltaX = x - dragState.startX / scale
            const deltaY = y - dragState.startY / scale

            const updatedBox = {
              ...dragState.originalBox,
              x: dragState.originalBox.x + deltaX,
              y: dragState.originalBox.y + deltaY,
            }

            updateBox(updatedBox)
          }
          return dragState;
        })

        // Get current resize state
        setResizeState((resizeState: ResizeState) => {
          // Handle resizing
          if (resizeState.isResizing && resizeState.originalBox && resizeState.handle) {
            const deltaX = x - resizeState.startX / scale
            const deltaY = y - resizeState.startY / scale
            const original = resizeState.originalBox
            let updatedBox = { ...original }

            // Apply resize based on which handle is being dragged
            switch (resizeState.handle) {
              case "top-left":
                updatedBox = {
                  ...original,
                  x: original.x + deltaX,
                  y: original.y + deltaY,
                  width: original.width - deltaX,
                  height: original.height - deltaY,
                }
                break
              case "top-right":
                updatedBox = {
                  ...original,
                  y: original.y + deltaY,
                  width: original.width + deltaX,
                  height: original.height - deltaY,
                }
                break
              case "bottom-left":
                updatedBox = {
                  ...original,
                  x: original.x + deltaX,
                  width: original.width - deltaX,
                  height: original.height + deltaY,
                }
                break
              case "bottom-right":
                updatedBox = {
                  ...original,
                  width: original.width + deltaX,
                  height: original.height + deltaY,
                }
                break
              case "top":
                updatedBox = {
                  ...original,
                  y: original.y + deltaY,
                  height: original.height - deltaY,
                }
                break
              case "right":
                updatedBox = {
                  ...original,
                  width: original.width + deltaX,
                }
                break
              case "bottom":
                updatedBox = {
                  ...original,
                  height: original.height + deltaY,
                }
                break
              case "left":
                updatedBox = {
                  ...original,
                  x: original.x + deltaX,
                  width: original.width - deltaX,
                }
                break
            }

            // Ensure width and height are positive
            if (updatedBox.width < 10) {
              updatedBox.width = 10
              if (["top-left", "bottom-left", "left"].includes(resizeState.handle)) {
                updatedBox.x = original.x + original.width - 10
              }
            }

            if (updatedBox.height < 10) {
              updatedBox.height = 10
              if (["top-left", "top-right", "top"].includes(resizeState.handle)) {
                updatedBox.y = original.y + original.height - 10
              }
            }

            updateBox(updatedBox)
          }
          return resizeState;
        })
      }
    }

    const handleMouseUp = () => {
      setDragState({
        isDragging: false,
        startX: 0,
        startY: 0,
        originalBox: null,
      })

      setResizeState({
        isResizing: false,
        handle: null,
        startX: 0,
        startY: 0,
        originalBox: null,
      })
    }

    window.addEventListener("mousemove", handleMouseMove)
    window.addEventListener("mouseup", handleMouseUp)
    window.addEventListener("touchend", handleMouseUp)

    return () => {
      window.removeEventListener("mousemove", handleMouseMove)
      window.removeEventListener("mouseup", handleMouseUp)
      window.removeEventListener("touchend", handleMouseUp)
    }
  }, [containerRef, scale, updateBox, setDragState, setResizeState])

  const startDragging = useCallback((e: React.MouseEvent | React.TouchEvent, box: BoundingBox) => {
    if (containerRef.current) {
      const rect = containerRef.current.getBoundingClientRect()

      let clientX, clientY
      if ("touches" in e) {
        // Touch event
        clientX = e.touches[0].clientX
        clientY = e.touches[0].clientY
      } else {
        // Mouse event
        clientX = e.clientX
        clientY = e.clientY
      }

      setDragState({
        isDragging: true,
        startX: clientX - rect.left,
        startY: clientY - rect.top,
        originalBox: box,
      })
      selectBox(box)
      e.stopPropagation()
    }
  }, [containerRef, selectBox, setDragState])

  const startResizing = useCallback((e: React.MouseEvent | React.TouchEvent, box: BoundingBox, handle: string) => {
    if (containerRef.current) {
      const rect = containerRef.current.getBoundingClientRect()

      let clientX, clientY
      if ("touches" in e) {
        // Touch event
        clientX = e.touches[0].clientX
        clientY = e.touches[0].clientY
      } else {
        // Mouse event
        clientX = e.clientX
        clientY = e.clientY
      }

      setResizeState({
        isResizing: true,
        handle,
        startX: clientX - rect.left,
        startY: clientY - rect.top,
        originalBox: box,
      })
      selectBox(box)
      e.stopPropagation()
    }
  }, [containerRef, selectBox, setResizeState])

  return {
    startDragging,
    startResizing
  }
}

export function useControlPanelState(
  boundingBoxes: BoundingBox[],
  externalEditingState?: {
    editingLabel: string;
    setEditingLabel: (label: string) => void;
  }
) {
  // Use external state if provided, otherwise create local state
  const [localEditingLabel, setLocalEditingLabel] = useState<string>("")
  const editingLabel = externalEditingState?.editingLabel ?? localEditingLabel
  const setEditingLabel = externalEditingState?.setEditingLabel ?? setLocalEditingLabel
  
  const [activeTab, setActiveTab] = useState<string>("elements")
  const [hoveredBoxId, setHoveredBoxId] = useState<number | null>(null)
  const [view, setView] = useState<"list" | "edit">("list")

  // Calculate total inference time
  const totalInferenceTime = useMemo(() => {
    return boundingBoxes.reduce((total, box) => total + box.inferenceTime, 0)
  }, [boundingBoxes])

  return {
    editingLabel,
    setEditingLabel,
    activeTab,
    setActiveTab,
    hoveredBoxId,
    setHoveredBoxId,
    view,
    setView,
    totalInferenceTime
  }
}

================
File: /Users/jess/Desktop/personal git/mobbin/formobbin/hooks/use-image-scale.tsx
================
import { useState, useEffect, RefObject } from "react"

export function useImageScale(
  image: File,
  containerRef: RefObject<HTMLDivElement>,
  imageRef: RefObject<HTMLImageElement>
) {
  const [imageUrl, setImageUrl] = useState<string>("")
  const [scale, setScale] = useState<number>(1)

  useEffect(() => {
    if (image) {
      const url = URL.createObjectURL(image)
      setImageUrl(url)
      return () => URL.revokeObjectURL(url)
    }
  }, [image])

  // Calculate scale factor when image loads or container resizes
  useEffect(() => {
    const updateScale = () => {
      if (imageRef.current && containerRef.current) {
        const containerWidth = containerRef.current.clientWidth
        const imageNaturalWidth = imageRef.current.naturalWidth

        if (imageNaturalWidth > containerWidth) {
          setScale(containerWidth / imageNaturalWidth)
        } else {
          setScale(1)
        }
      }
    }

    // Update scale when image loads
    if (imageRef.current) {
      imageRef.current.onload = updateScale
    }

    // Update scale on window resize
    window.addEventListener("resize", updateScale)
    return () => window.removeEventListener("resize", updateScale)
  }, [imageUrl])

  return { imageUrl, scale }
}

================
File: /Users/jess/Desktop/personal git/mobbin/formobbin/hooks/use-mobile.tsx
================
"use client"

import { useEffect, useState } from "react"

export function useIsMobile() {
  const [isMobile, setIsMobile] = useState(false)

  useEffect(() => {
    const checkIfMobile = () => {
      setIsMobile(window.innerWidth < 768)
    }

    // Initial check
    checkIfMobile()

    // Add event listener
    window.addEventListener("resize", checkIfMobile)

    // Clean up
    return () => {
      window.removeEventListener("resize", checkIfMobile)
    }
  }, [])

  return isMobile
}
