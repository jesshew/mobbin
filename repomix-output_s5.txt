This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-04-24T12:38:24.766Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
/
  Users/
    jess/
      Desktop/
        personal git/
          mobbin/
            formobbin/
              lib/
                services/
                  ai/
                    ClaudeAIService.ts
                    MoondreamAIService.ts
                    MoondreamDetectionService.js
                    MoondreamVLService.js
                    OpenAIService.js
                  imageServices/
                    BoundingBoxService.js
                    imageFetchingService.ts
                    ImageProcessor.ts
                    screenshotProcessor.ts
                  batchProcessingService.ts
                  DatabaseService.ts
                  ParallelAnnotationService.ts
                  ParallelExtractionService.ts
                  sample_vision_api_call.txt
              types/
                BatchProcessingScreenshot.ts
                DetectionResult.ts

================================================================
Repository Files
================================================================

================
File: /Users/jess/Desktop/personal git/mobbin/formobbin/lib/services/ai/ClaudeAIService.ts
================
import Anthropic from '@anthropic-ai/sdk';
import { PromptResult } from '../../../types/PromptRunner'; // adjust path as needed
import { EXTRACT_ELEMENTS_PROMPT_v2, ANCHOR_ELEMENTS_PROMPT_v0, ANCHOR_ELEMENTS_PROMPT_v1, ANCHOR_ELEMENTS_PROMPT_v2, EXTRACT_ELEMENTS_PROMPT_v3, ANCHOR_ELEMENTS_PROMPT_v3 } from '@/lib/prompt/prompts';
import { PromptTrackingContext } from '@/lib/logger';
import { PromptLogType } from '@/lib/constants';
import { cleanText } from '@/lib/file-utils'; 
// Ensure your Claude API key is set in ENV
const anthropic = new Anthropic({
  apiKey: process.env.ANTHROPIC_API_KEY,
});

// Specify the Claude vision model version
const VISION_MODEL_CLAUDE = 'claude-3-7-sonnet-20250219';
const VISION_MODEL_HAIKU = 'claude-3-5-haiku-20241022';

// Constants for token cost calculation (update with actual costs)
const CLAUDE_INPUT_TOKEN_COST = 0.000015; // example cost per input token
const CLAUDE_OUTPUT_TOKEN_COST = 0.000060; // example cost per output token

/**
 * Calls the Claude vision-capable model with a text prompt and optional image URL.
 *
 * @param prompt   - The text prompt to send.
 * @param imageUrl - Optional URL of an image for the model to analyze.
 * @param context  - The tracking context containing batch, screenshot, and other IDs
 * @param promptType - The type of prompt being processed.
 * @returns        - A structured PromptResult containing the response, timing, and token usage.
 */
export async function callClaudeVisionModel(
  prompt: string,
  imageUrl: string | null,
  context: PromptTrackingContext,
  promptType: PromptLogType.ELEMENT_EXTRACTION | PromptLogType.ANCHORING
): Promise<any> {
  // Build the Anthropic messages payload
  const messages = [
    {
      role: 'user',
      content: [
        // include image if provided
        imageUrl && {
          type: 'image',
          source: { type: 'url', url: imageUrl }
        },
        { type: 'text', text: prompt }
      ].filter(Boolean),
    },
  ];

  try {
    // Start timing right before the API call
    const startTime = Date.now();
    
    const response = await anthropic.messages.create({
      // model: VISION_MODEL_HAIKU,
      model: VISION_MODEL_CLAUDE,
      max_tokens: 8192, // tweak as needed
      messages: messages as Anthropic.MessageParam[],
    });
    
    // End timing right after the API call
    const endTime = Date.now();
    const durationMs = endTime - startTime;

    // Extract usage data
    const inputTokens = response?.usage?.input_tokens || 0;
    const outputTokens = response?.usage?.output_tokens || 0;
    
    // Log the interaction using the context with the measured duration
    await context.logPromptInteraction(
      `Claude-${VISION_MODEL_CLAUDE}`,
      promptType,
      prompt,
      JSON.stringify(response),
      durationMs,
      {
        input: inputTokens,
        output: outputTokens,
        total: inputTokens + outputTokens
      },
      CLAUDE_INPUT_TOKEN_COST,
      CLAUDE_OUTPUT_TOKEN_COST
    );

    return response;
  } catch (err) {
    console.error('Error calling Claude Vision Model:', err);
    throw new Error(
      `Failed to get response from Claude: ${
        err instanceof Error ? err.message : String(err)
      }`
    );
  }
}

/**
 * Extracts components from an image using the OpenAI vision model.
 *
 * @param imageUrl The URL of the image to analyze.
 * @param component_list The list of components to guide the extraction.
 * @param context The tracking context containing batch, screenshot, and other IDs
 * @returns A promise resolving to the structured PromptResult.
 * @throws Throws an error if the API call fails.
 */
export async function extract_element_from_image(
  imageUrl: string, 
  component_list: string,
  context: PromptTrackingContext
) {
  // Define the prompt for extraction
  const prompt = EXTRACT_ELEMENTS_PROMPT_v2 + `\n\n<component_list>${component_list}</component_list>`;
  const response = await callClaudeVisionModel(
    prompt, 
    imageUrl, 
    context,
    PromptLogType.ELEMENT_EXTRACTION
  );

  const { parsedContent, rawText, usage } = extractClaudeResponseData(response);

  // Call the OpenAI vision model with the prompt and image URL
  return { parsedContent, rawText, usage };
}

/**
 * Extracts anchor elements from an image using the Claude vision model.
 *
 * @param imageUrl The URL of the image to analyze.
 * @param element_list The list of elements to guide the extraction.
 * @param context The tracking context containing batch, screenshot, and other IDs
 * @returns A promise resolving to the structured PromptResult.
 * @throws Throws an error if the API call fails.
 */
export async function anchor_elements_from_image(
  imageUrl: string, 
  element_list: string,
  context: PromptTrackingContext
) {
  // Define the prompt for anchor extraction
  const prompt = ANCHOR_ELEMENTS_PROMPT_v3 + `\n\n<element_list>${element_list}</element_list>`;
  const response = await callClaudeVisionModel(
    prompt, 
    imageUrl,
    context,
    PromptLogType.ANCHORING
  );

  const { parsedContent, rawText, usage } = extractClaudeResponseData(response);

  // Call the Claude vision model with the prompt and image URL
  return { parsedContent, rawText,usage };
}



/**
 * Cleans the raw text and returns a list of components.
 *
 * @param components - The array of components to filter and clean.
 * @returns Array of cleaned strings in the format "component_name: description".
 */
function cleanTextToList(components: any[]): string[] {
  return components
    .filter(component => typeof component?.component_name === 'string' && typeof component?.description === 'string')
    .map(component => `${component.component_name}: ${component.description}`);
}

/**
 * Helper: Parses Claude's text content into a JSON object safely.
 * Handles common formatting quirks like trailing commas or line breaks.
 * Searches for JSON content within the response text.
 *
 * @param rawText - Raw text string returned from Claude.
 * @returns Parsed JSON object.
 */
function parseClaudeTextToJson(rawText: string): Record<string, string> {
  try {
    // Look for JSON pattern in the text - either within code blocks or standalone
    const jsonRegex = /```(?:json)?\s*({[\s\S]*?})\s*```|({[\s\S]*})/;
    const match = rawText.match(jsonRegex);
    
    let jsonContent = '';
    if (match) {
      // Use the first matched group that contains content
      jsonContent = match[1] || match[2];
    } else {
      // Fall back to using the entire text
      jsonContent = rawText;
    }
    
    const cleanedText = cleanText(jsonContent);
    return JSON.parse(cleanedText);
  } catch (error) {
    console.error('Failed to parse Claude response as JSON:', error);
    return {};
  }
}

/**
 * Extracts structured content text and usage metadata from Claude's response.
 *
 * @param response - Full Claude response object.
 * @returns Object containing parsed text content and usage details.
 */
export function extractClaudeResponseData(response: any): {
  parsedContent: Record<string, string>,
  rawText: string,
  usage: {
    input_tokens?: number,
    output_tokens?: number
  }
} {
  const rawText = response?.content?.find((item: any) => item.type === 'text')?.text ?? '';

  const parsedContent = parseClaudeTextToJson(rawText);

  const usage = {
    input_tokens: response?.usage?.input_tokens,
    output_tokens: response?.usage?.output_tokens,
  };

  return {
    parsedContent,
    rawText,
    usage,
  };
}

================
File: /Users/jess/Desktop/personal git/mobbin/formobbin/lib/services/ai/MoondreamAIService.ts
================
// THIS DOES NOT WORK. DO NOT USE OR MODIFY.

import { PromptTrackingContext } from '@/lib/logger';
import { MOON_DREAM_API_KEY } from '@/config';
import { PromptLogType } from '@/lib/constants';
/**
 * Interface for the detect API response
 */
interface DetectResponse {
  request_id: string;
  objects: Array<{
    x_min: number;
    y_min: number;
    x_max: number;
    y_max: number;
  }>;
}

/**
 * Converts a Blob to a base64 string with data URI prefix
 * 
 * @param blob - The Blob to convert
 * @param mimeType - The MIME type of the image (defaults to 'image/jpeg')
 * @returns A promise resolving to a base64 string with data URI prefix
 */
export async function blobToBase64(blob: Blob, mimeType: string = 'image/jpeg'): Promise<string> {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onloadend = () => {
      if (typeof reader.result === 'string') {
        resolve(reader.result);
      } else {
        reject(new Error('FileReader did not return a string'));
      }
    };
    reader.onerror = reject;
    reader.readAsDataURL(blob);
  });
}

/**
 * Fetches image data from a URL
 * 
 * @param imageUrl - URL of the image to fetch
 * @returns A promise resolving to the image blob
 */
export async function fetchImageFromUrl(imageUrl: string): Promise<Blob> {
  const imageResponse = await fetch(imageUrl);
  const imageBlob = await imageResponse.blob();
  return imageBlob;
}

/**
 * Calls the Moondream API to detect objects in images
 * 
 * @param imageUrl - URL of the image to analyze
 * @param object - The object type to detect (e.g., "person", "car", "face")
 * @param context - The tracking context containing batch, screenshot, and component IDs
 * @returns A promise resolving to the detection response
 */
export async function detectObjectsFromImage(
  imageUrl: string,
  object: string,
  context: PromptTrackingContext
): Promise<DetectResponse> {
  console.log(`CALLING MOONDREAM API: Object=${object}, ImageURL=${imageUrl}`);

  // Fetch the image data from URL
  const imageBlob = await fetchImageFromUrl(imageUrl);

  // Create form data with image and object parameters
  const formData = new FormData();
  formData.append('image', imageBlob);
  formData.append('object', object);

  try {
    // Start timing right before the API call
    const startTime = Date.now();
    
    const response = await fetch('https://api.moondream.ai/v1/detect', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${MOON_DREAM_API_KEY}`
      },
      body: formData
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Moondream API error (${response.status}): ${errorText}`);
    }

    const result = await response.json() as DetectResponse;
    
    // End timing right after the API call finishes
    const endTime = Date.now();
    const durationMs = endTime - startTime;
    
    // Log the interaction using the context with the measured duration
    await context.logPromptInteraction(
      'Moondream-Detect',
      PromptLogType.VLM_LABELING,
      `Detect ${object} in image`,
      JSON.stringify(result),
      durationMs,
      // Moondream doesn't provide token usage, so we leave these undefined
      {
        input: undefined,
        output: undefined,
        total: undefined
      }
    );

    return result;
  } catch (err) {
    console.error('Error calling Moondream API:', err);
    throw new Error(
      `Failed to get response from Moondream: ${
        err instanceof Error ? err.message : String(err)
      }`
    );
  }
}

/**
 * Converts the normalized coordinates to pixel coordinates
 * 
 * @param coordinates - Object with normalized coordinates (0-1)
 * @param imageWidth - Width of the image in pixels
 * @param imageHeight - Height of the image in pixels
 * @returns Object with pixel coordinates
 */
export function normalizedToPixelCoordinates(
  coordinates: { x_min: number; y_min: number; x_max: number; y_max: number },
  imageWidth: number,
  imageHeight: number
) {
  return {
    x_min: Math.round(coordinates.x_min * imageWidth),
    y_min: Math.round(coordinates.y_min * imageHeight),
    x_max: Math.round(coordinates.x_max * imageWidth),
    y_max: Math.round(coordinates.y_max * imageHeight)
  };
} 

/**
 * Detect objects in an image blob via Moondream API.
 *
 * @param imageBlob  – Image data as a Blob
 * @param objectType – The object type to detect (e.g. "person", "car", "face")
 * @param context - The tracking context containing batch, screenshot, and component IDs
 */
export async function detectObjectsFromBlob(
  imageBlob: Blob,
  objectType: string,
  context: PromptTrackingContext
): Promise<DetectResponse> {
  console.log(`CALLING MOONDREAM API: Object=${objectType}, Blob input`);

  const formData = new FormData();
  formData.append('image', imageBlob);
  formData.append('object', objectType);

  // Start timing right before the API call
  const startTime = Date.now();
  
  const resp = await fetch('https://api.moondream.ai/v1/detect', {
    method: 'POST',
    headers: { 'Authorization': `Bearer ${MOON_DREAM_API_KEY}` },
    body: formData
  });

  if (!resp.ok) {
    const txt = await resp.text();
    throw new Error(`Moondream API error (${resp.status}): ${txt}`);
  }

  const result = (await resp.json()) as DetectResponse;
  
  // End timing right after the API call finishes
  const endTime = Date.now();
  const durationMs = endTime - startTime;

  // Log the interaction using the context with the measured duration
  await context.logPromptInteraction(
    'Moondream-Detect',
    PromptLogType.VLM_LABELING,
    `Detect ${objectType} in blob`,
    JSON.stringify(result),
    durationMs,
    { input: undefined, output: undefined, total: undefined }
  );

  return result;
}

/**
 * Detect objects in a base64 encoded image via Moondream API.
 *
 * @param imageBase64 – Image data as a base64 string with data URI prefix
 * @param objectType – The object type to detect (e.g. "person", "car", "face")
 * @param context - The tracking context containing batch, screenshot, and component IDs
 */
export async function detectObjectsFromBase64(
  imageBase64: string,
  objectType: string,
  context: PromptTrackingContext
): Promise<DetectResponse> {
  if (!MOON_DREAM_API_KEY) {
    console.error('[Moondream] MOON_DREAM_API_KEY is undefined – check your environment variables.');
    throw new Error(
      '[Moondream] MOON_DREAM_API_KEY is undefined – check your environment variables.'
    );
  }

  console.log(`CALLING MOONDREAM API: Object=${objectType}, Base64 input`);

  // Convert base64 to a blob for FormData compatibility
  const formData = new FormData();
  
  // Create a Blob from the base64 string by removing the data URI prefix if present
  let base64Data = imageBase64;
  if (base64Data.startsWith('data:')) {
    base64Data = base64Data.split(',')[1];
  }
  
  // Convert base64 to binary
  const binaryStr = atob(base64Data);
  const byteArray = new Uint8Array(binaryStr.length);
  for (let i = 0; i < binaryStr.length; i++) {
    byteArray[i] = binaryStr.charCodeAt(i);
  }
  
  // Create blob from binary data
  const blob = new Blob([byteArray], { type: 'image/jpeg' });
  
  // Append to form data
  formData.append('image_url', blob);
  formData.append('object', objectType);

  // Start timing right before the API call
  const startTime = Date.now();
  
  const resp = await fetch('https://api.moondream.ai/v1/detect', {
    method: 'POST',
    headers: { 
      'Authorization': `Bearer ${MOON_DREAM_API_KEY}`
    },
    body: formData
  });

  if (!resp.ok) {
    const txt = await resp.text();
    throw new Error(`Moondream API error (${resp.status}): ${txt}`);
  }

  const result = (await resp.json()) as DetectResponse;
  
  // End timing right after the API call finishes
  const endTime = Date.now();
  const durationMs = endTime - startTime;

  // Log the interaction using the context with the measured duration
  await context.logPromptInteraction(
    'Moondream-Detect',
    PromptLogType.VLM_LABELING,
    `Detect ${objectType} in base64 image`,
    JSON.stringify(result),
    durationMs,
    { input: undefined, output: undefined, total: undefined }
  );

  return result;
}

================
File: /Users/jess/Desktop/personal git/mobbin/formobbin/lib/services/ai/MoondreamDetectionService.js
================
import { detectObjectsFromBuffer, normalizedToPixelCoordinates } from '@/lib/services/ai/MoondreamVLService';
import fs from 'fs';
import path from 'path';
import Jimp from 'jimp';
import { logPromptInteraction, logPromptToDatabase, PromptTrackingContext, createScreenshotTrackingContext } from '@/lib/logger';
import pLimit from 'p-limit';
import {
  BOX_COLOR,
  BOX_WIDTH,
  OVERLAY_COLOR,
  generateAnnotatedImageBuffer,
  saveAnnotatedImageDebug,
  normalizeLabel
} from '@/lib/services/imageServices/BoundingBoxService';

// --- Constants ---
const API_RETRY_DELAY_MS = 1000;
const CONCURRENCY_LIMIT = 5;
const VLM_MODEL_NAME = 'moondream'; // Define the model name being used

// --- Type Imports (using JSDoc for type hinting in JS) ---
/**
 * @typedef {import('../../types/DetectionResult').ElementDetectionItem} ElementDetectionItem
 * @typedef {import('../../types/DetectionResult').ComponentDetectionResult} ComponentDetectionResult
 */

/**
 * Extracts the first level of the label hierarchy
 * @param {string} label - The full hierarchical label
 * @returns {string} First level category
 */
function getFirstLevelCategory(label) {
  return label.split(' > ')[0];
}

/**
 * Determines the appropriate grouping category for hierarchical labels
 * Elements are grouped by mid-level categories if they have >2 children
 * 
 * This algorithm implements a dynamic grouping strategy for hierarchical labels:
 * 1. Creates a tree structure representing the label hierarchy
 * 2. Identifies nodes with >2 children or direct elements
 * 3. Promotes these nodes as standalone categories
 * 4. Assigns each element to its deepest eligible category
 * 
 * Example:
 * For "Operational Risk Overview > ICU Department > Occupancy", 
 * if "ICU Department" has >2 child elements, it becomes the category
 * instead of just "Operational Risk Overview".
 * 
 * @param {string[]} allLabels - Array of all hierarchical labels (e.g. "Parent > Child > Grandchild")
 * @returns {Object} Map of labels to their assigned category
 */
function determineHierarchicalGroups(allLabels) {
  // Step 1: Build a tree structure from all labels
  const hierarchy = {};
  
  // Count elements under each prefix
  allLabels.forEach(label => {
    const parts = label.split(' > ');
    
    // Initialize all paths in the hierarchy for this label
    for (let i = 0; i < parts.length; i++) {
      const currentPath = parts.slice(0, i + 1).join(' > ');
      
      if (!hierarchy[currentPath]) {
        hierarchy[currentPath] = {
          count: 0,          // Number of leaf nodes directly assigned to this path
          level: i + 1,      // Depth in the hierarchy (1 = top level)
          parent: i > 0 ? parts.slice(0, i).join(' > ') : null,
          children: new Set() // Set of immediate child paths
        };
      }
      
      // If this is a leaf node (full path), increment leaf count
      if (i === parts.length - 1) {
        hierarchy[currentPath].count++;
      }
      
      // Add as child to parent node
      if (i > 0) {
        const parentPath = parts.slice(0, i).join(' > ');
        if (hierarchy[parentPath]) {
          hierarchy[parentPath].children.add(currentPath);
        }
      }
    }
  });
  
  // Log the hierarchy structure (debug only)
  if (process.env.DEBUG_HIERARCHY === 'true') {
    console.log('=== Label Hierarchy ===');
    Object.entries(hierarchy).forEach(([path, node]) => {
      console.log(`${path} (Level ${node.level}): ${node.count} direct elements, ${node.children.size} children`);
    });
    console.log('======================');
  }
  
  // Step 2: Find the appropriate category for each label
  const labelToCategory = {};
  
  allLabels.forEach(label => {
    const parts = label.split(' > ');
    let bestCategory = parts[0]; // Default to top level
    let bestLevel = 1;
    
    // Find the deepest qualifying category
    for (let i = 0; i < parts.length; i++) { 
      const currentPath = parts.slice(0, i + 1).join(' > ');
      const node = hierarchy[currentPath];
      
      if (!node) continue;
      
      // Determine if this node qualifies as a category:
      // 1. Always include top level
      // 2. If node has >2 children or contains >2 elements directly
      const childCount = node.children.size;
      const hasEnoughChildren = childCount > 2 || node.count > 2;
      
      if (i === 0 || hasEnoughChildren) {
        // This is a better category than what we have
        if (node.level > bestLevel) {
          bestCategory = currentPath;
          bestLevel = node.level;
        }
      }
    }
    
    labelToCategory[label] = bestCategory;
  });
  
  // Log some stats about the grouping results
  const categoryCounts = {};
  Object.values(labelToCategory).forEach(category => {
    categoryCounts[category] = (categoryCounts[category] || 0) + 1;
  });
  
  const uniqueCategories = Object.keys(categoryCounts);
  console.log(`Created ${uniqueCategories.length} groupings from ${allLabels.length} elements:`);
  uniqueCategories.forEach(category => {
    console.log(`- ${category}: ${categoryCounts[category]} elements`);
  });
  
  return labelToCategory;
}

/**
 * Creates an output directory with timestamp
 * @returns {Promise<string>} Path to the created directory
 */
async function createOutputDirectory() {
  const timestamp = new Date().toISOString().replace(/[:.-]/g, '').replace('T', '_').slice(0, 15);
  const outputDir = `mobbin_attempt_folder/detection_output_${timestamp}`;
  
  try {
    await fs.promises.mkdir(outputDir, { recursive: true });
    console.log(`Output directory created: ${outputDir}`);
    return outputDir;
  } catch (err) {
    console.error(`Failed to create output directory: ${err}`);
    throw err;
  }
}

/**
 * Saves JSON data to a file
 * @param {Object} data - The data to save
 * @param {string} filePath - Path to save the JSON file
 * @returns {Promise<void>}
 */
async function saveJson(data, filePath) {
  try {
    // Only save if needed (e.g., for debugging)
    if (process.env.SAVE_DEBUG_FILES === 'true') {
        await fs.promises.writeFile(filePath, JSON.stringify(data, null, 4));
        // console.log(`Debug JSON data saved successfully to: ${filePath}`);
    }
  } catch (err) {
    console.error(`Error saving debug JSON file to ${filePath}: ${err}`);
  }
}

/**
 * Processes a single description to detect objects
 * @param {Buffer} imageBuffer - The image buffer
 * @param {string} description - The object description to detect
 * @param {PromptTrackingContext} context - The tracking context containing batch, screenshot, and component IDs
 * @returns {Promise<{objects: Array, duration: number}>} Detected objects and duration
 */
async function detectSingleObject(imageBuffer, description, context) {
  try {
    // Create a component-specific context if this detection is for a specific component
    const componentContext = context.componentId 
      ? context 
      : context; // Use as-is if no component ID present yet

    // We measure only the API call duration, which is handled inside detectObjectsFromBuffer
    const result = await detectObjectsFromBuffer(imageBuffer, description, componentContext);
    
    // The API call duration is already tracked in detectObjectsFromBuffer
    if (result && result.objects && result.objects.length > 0) {
      return { objects: result.objects, duration: 0 }; // Duration is already logged
    } else {
      return { objects: [], duration: 0 }; // Duration is already logged
    }
  } catch (err) {
    console.error(`Error during detection for '${description}': ${err}`);
    throw err; // Let the caller handle the error state
  }
}

/**
 * Process detected objects and scale coordinates to absolute pixel values
 * @param {Array} detectedObjectsList - List of raw detection objects
 * @param {string} label - The label being processed
 * @param {number} imgWidth - Image width in pixels
 * @param {number} imgHeight - Image height in pixels
 * @returns {Array<{x_min: number, y_min: number, x_max: number, y_max: number}>} List of processed bounding boxes
 */
function processBoundingBoxes(detectedObjectsList, label, imgWidth, imgHeight) {
  const boundingBoxes = [];

  for (const rawDetection of detectedObjectsList) {
    try {
      if ('x_min' in rawDetection && 'y_min' in rawDetection && 'x_max' in rawDetection && 'y_max' in rawDetection) {
        const scaledCoords = normalizedToPixelCoordinates(rawDetection, imgWidth, imgHeight);
        boundingBoxes.push(scaledCoords);
      } else {
        console.warn(`Skipping a detection for label '${label}' due to missing coordinate keys in:`, rawDetection);
      }
    } catch (err) {
      console.error(`Error scaling coordinates for one detection of label '${label}': ${err}`);
      // Decide how to handle scaling errors - skip this box or mark as error?
    }
  }

  return boundingBoxes;
}

/**
 * Main processing function: detects objects, groups by category, generates annotated images/data.
 * Returns structured results per component/category.
 * @param {number} screenshotId - ID of the screenshot being processed
 * @param {Buffer} imageBuffer - Buffer containing the image data
 * @param {Object.<string, string>} labelsDict - Dictionary of {label: description}
 * @param {number} batchId - The ID of the batch this operation is part of
 * @returns {Promise<ComponentDetectionResult[]>} Array of detection results for each component/category.
 */
export async function processAndSaveByCategory(screenshotId, imageBuffer, labelsDict, batchId) {
  const overallStartTime = performance.now();
  let outputDir = null; // Only needed if saving debug files
  if (process.env.SAVE_DEBUG_FILES === 'true') {
      outputDir = await createOutputDirectory();
  }
  const limit = pLimit(CONCURRENCY_LIMIT);
  const componentResults = [];

  // Create a tracking context for this screenshot
  const context = createScreenshotTrackingContext(batchId, screenshotId);

  try {
    // --- Image Validation ---
    let validatedImageBuffer = imageBuffer;
    let jimpImage;
    try {
      jimpImage = await Jimp.read(imageBuffer);
    } catch (err) {
      console.error(`Invalid initial image format for screenshot ${screenshotId}: ${err.message}. Attempting conversion...`);
      try {
        // Attempt conversion (e.g., from JPEG or WEBP to PNG buffer)
        const tempImage = await Jimp.read(imageBuffer);
        validatedImageBuffer = await tempImage.getBufferAsync(Jimp.MIME_PNG);
        jimpImage = await Jimp.read(validatedImageBuffer); // Read the converted buffer
        console.log(`Image conversion successful for screenshot ${screenshotId}.`);
      } catch (convErr) {
        // If conversion fails, we cannot proceed with this screenshot
        console.error(`FATAL: Image conversion failed for screenshot ${screenshotId}: ${convErr.message}. Skipping detection for this image.`);
        // Return an empty array or a specific error result? Empty array for now.
        return [];
        // Or: throw new Error(`Could not process image for screenshot ${screenshotId}: ${convErr.message}`);
      }
    }
    const imgWidth = jimpImage.getWidth();
    const imgHeight = jimpImage.getHeight();

    // --- Parallel Detection ---
    const labelEntries = Object.entries(labelsDict);
    console.log(`[Screenshot ${screenshotId}] Starting detection for ${labelEntries.length} labels with concurrency ${CONCURRENCY_LIMIT}`);

    // Intermediate structure to hold results per label
    const detectionResultsByLabel = {};

    const detectionTasks = labelEntries.map(([label, description]) =>
      limit(async () => {
        // console.log(`[Screenshot ${screenshotId}] Starting detection for: '${label}'`);
        let detectionData = { objects: [], duration: 0, error: null };
        let status = 'Not Detected';
        try {
            detectionData = await detectSingleObject(validatedImageBuffer, description, context);
            status = detectionData.objects.length > 0 ? 'Detected' : 'Not Detected';
            // console.log(`[Screenshot ${screenshotId}] Finished detection for: '${label}' (Found: ${detectionData.objects.length})`);
        } catch (error) {
            console.error(`[Screenshot ${screenshotId}] Error in detectSingleObject for '${label}':`, error);
            detectionData.error = error;
            status = 'Error'; // Mark detection as errored
        }
        return { label, description, rawDetections: detectionData.objects, duration: detectionData.duration, status, error: detectionData.error };
      })
    );

    const settledDetectionTasks = await Promise.allSettled(detectionTasks);
    console.log(`[Screenshot ${screenshotId}] All detection tasks settled.`);

    // --- Process and Group Results ---
    // First get all labels for dynamic grouping determination
    const allLabels = labelEntries.map(([label]) => label);
    const labelToGroupMap = determineHierarchicalGroups(allLabels);
    
    const elementsByCategory = {};

    settledDetectionTasks.forEach((result, index) => {
      const [originalLabel, originalDescription] = labelEntries[index]; // Get label/desc based on original index

      if (result.status === 'fulfilled') {
        const { label, description, rawDetections, duration, status: detectionStatus, error } = result.value;

        const elementItem = {
          label: label,
          description: description,
          bounding_box: null, // Will be populated if coordinates are valid
          status: detectionStatus,
          vlm_model: VLM_MODEL_NAME,
          element_inference_time: duration, // Time for this specific label's detection
          // accuracy_score: undefined, // To be added later
          // suggested_coordinates: undefined, // To be added later
          error: error ? (error.message || 'Detection Error') : null
        };

        if (detectionStatus === 'Detected' && rawDetections.length > 0) {
          // Currently takes the first box if multiple are returned for one description.
          // Consider how to handle multiple boxes for a single label if needed.
          const boundingBoxes = processBoundingBoxes(rawDetections.slice(0, 1), label, imgWidth, imgHeight);
          if (boundingBoxes.length > 0) {
            elementItem.bounding_box = boundingBoxes[0]; // Assign the first valid box
          } else {
            // Detected but failed coordinate scaling
            elementItem.status = 'Error';
            elementItem.error = elementItem.error || 'Coordinate scaling failed';
            console.warn(`[Screenshot ${screenshotId}] Processed '${label}': Detected but failed to scale coordinates.`);
          }
        } else if (detectionStatus === 'Error') {
            console.warn(`[Screenshot ${screenshotId}] Processed '${label}': Detection failed.`);
        } else {
           // console.log(`[Screenshot ${screenshotId}] Processed '${label}': Not detected.`);
        }

        // Use the dynamically determined category instead of just first level
        const categoryName = labelToGroupMap[label] || getFirstLevelCategory(label);
        
        if (!elementsByCategory[categoryName]) {
          elementsByCategory[categoryName] = [];
        }
        elementsByCategory[categoryName].push(elementItem);

      } else {
        // Task itself failed (rejected promise from p-limit queue, shouldn't happen often with try/catch inside)
        console.error(`[Screenshot ${screenshotId}] Detection task failed unexpectedly for label '${originalLabel}':`, result.reason);
        
        // Use the dynamically determined category instead of just first level
        const categoryName = labelToGroupMap[originalLabel] || getFirstLevelCategory(originalLabel);
        
        if (!elementsByCategory[categoryName]) {
          elementsByCategory[categoryName] = [];
        }
        elementsByCategory[categoryName].push({
          label: originalLabel,
          description: originalDescription,
          bounding_box: null,
          status: 'Error',
          vlm_model: VLM_MODEL_NAME,
          element_inference_time: 0, // Unknown duration
          error: result.reason?.message || 'Unknown task error'
        });
      }
    });

    // --- Generate Component Results (Image Buffer + Data) ---
    const componentProcessingPromises = Object.entries(elementsByCategory).map(async ([categoryName, elements]) => {
        const categoryStartTime = performance.now();

        // Filter items relevant for drawing (successfully detected with boxes)
        const detectedElements = elements.filter(el => el.status === 'Detected' && el.bounding_box);

        // Generate annotated image buffer for this category
        /** @type {Buffer | null} */
        const annotatedImageBuffer = await generateAnnotatedImageBuffer(
            validatedImageBuffer,
            detectedElements,
            BOX_COLOR, // Use a consistent color or cycle colors per category if needed
            categoryName
        );

        // Save debug image if enabled and buffer exists
        if (outputDir && annotatedImageBuffer) {
           await saveAnnotatedImageDebug(annotatedImageBuffer, categoryName, outputDir);
        }
        // Save debug JSON if enabled
        if (outputDir) {
            const normalizedKey = normalizeLabel(categoryName);
            const jsonPath = path.join(outputDir, `${normalizedKey}.json`);
            await saveJson({ screenshotId, categoryName, elements }, jsonPath); // Save all elements for the category
        }


        // Determine overall status for the component
        let componentStatus = 'failed';
        const hasSuccess = elements.some(el => el.status === 'Detected');
        const hasError = elements.some(el => el.status === 'Error');
        if (hasSuccess && !hasError) {
            componentStatus = 'success';
        } else if (hasSuccess && hasError) {
            componentStatus = 'partial';
        } else if (!hasSuccess && hasError) {
            componentStatus = 'failed'; // All elements failed or errored
        } else {
            componentStatus = 'failed'; // No elements detected or processed successfully
        }

        // Aggregate inference time (sum of individual element times)
        const totalInferenceTime = elements.reduce((sum, el) => sum + el.element_inference_time, 0);

        // Construct the ComponentDetectionResult
        /** @type {ComponentDetectionResult} */
        const componentResult = {
            screenshot_id: screenshotId,
            component_name: categoryName,
            // Use placeholder buffer if generation failed? Or handle null upstream? Using null for now.
            annotated_image_object: annotatedImageBuffer,
            annotated_image_url: undefined, // To be filled after upload
            // TODO: Define how to get a meaningful component_description. Using category name for now.
            component_description: `Detection results for ${categoryName}`,
            detection_status: componentStatus,
            inference_time: totalInferenceTime, // Or use category wall time: performance.now() - categoryStartTime;
            elements: elements, // Include all elements (detected, not detected, error)
        };

        componentResults.push(componentResult);
        // console.log(`[Screenshot ${screenshotId}] Finished processing component: '${categoryName}'`);
    });

    await Promise.all(componentProcessingPromises);

    const overallDuration = performance.now() - overallStartTime;
    console.log(`[Screenshot ${screenshotId}] Annotation Complete. Total time: ${overallDuration.toFixed(2)/1000}s`);
    return componentResults;

  } catch (err) {
    // Catch errors during initial setup (e.g., image reading/conversion)
    console.error(`[Screenshot ${screenshotId}] FATAL error during Moondream processing setup:`, err);
    // Return empty array to indicate failure for this screenshot
    return [];
  }
}

/**
 * Processes an image from a file path using labels dictionary
 * @param {string} imagePath - Path to the image file
 * @param {Object} labelsDict - Dictionary of labels and their descriptions
 * @returns {Promise<Object|null>} Categories with their detected items
 */
export async function processImageFile(imagePath, labelsDict) {
  try {
    let imageBuffer = await fs.promises.readFile(imagePath);
    console.log(`Image loaded successfully from: ${imagePath}`);
    
    return processAndSaveByCategory(imageBuffer, labelsDict);
  } catch (err) {
    console.error(`Error processing image ${imagePath}: ${err}`);
    return null;
  }
}

================
File: /Users/jess/Desktop/personal git/mobbin/formobbin/lib/services/ai/MoondreamVLService.js
================
import { vl } from 'moondream';
import { PromptTrackingContext } from '@/lib/logger';
import { MOON_DREAM_API_KEY } from '@/config';
import fs from 'fs';

/**
 * Type definition for detection results
 */
export const DetectionResultType = {
  request_id: String,
  objects: Array
};

/**
 * Initialize the vl model with API key
 */
const model = new vl({ apiKey: `${MOON_DREAM_API_KEY}` });

/**
 * Detect objects in an image using Moondream vl client
 * 
 * @param {Buffer} imageBuffer - Buffer containing image data
 * @param {string} objectType - The object type to detect (e.g., "person", "car", "face")
 * @param {PromptTrackingContext} context - The tracking context containing batch, screenshot, and component IDs
 * @returns {Promise<Object>} A promise resolving to the detection response
 */
export async function detectObjectsFromBuffer(
  imageBuffer, 
  objectType, 
  context
) {
  try {
    // Timing specifically the API call, not surrounding logic
    const startTime = Date.now();
    
    const result = await model.detect({
      image: imageBuffer,
      object: objectType
    });
    
    const endTime = Date.now();
    const durationMs = endTime - startTime;
    
    // Log the interaction using the context with the measured duration
    await context.logPromptInteraction(
      'Moondream-vl-Detect',
      'vlm_labeling',
      `Detect ${objectType} in image`,
      JSON.stringify(result),
      durationMs,
      {
        // Moondream doesn't provide token usage, so we leave these undefined
        input: undefined,
        output: undefined,
        total: undefined
      }
    );

    console.log(`-- [Detected] "${objectType.slice(0,50)}..." in ${durationMs/1000}s`);
    return {
      request_id: result.request_id,
      objects: result.objects
    };
  } catch (err) {
    console.error('Error using Moondream vl:', err);
    throw new Error(
      `Failed to get response from Moondream vl: ${
        err instanceof Error ? err.message : String(err)
      }`
    );
  }
}

/**
 * Converts the normalized coordinates to pixel coordinates
 * 
 * @param {Object} coordinates - Object with normalized coordinates (0-1)
 * @param {number} coordinates.x_min - Minimum x coordinate (0-1)
 * @param {number} coordinates.y_min - Minimum y coordinate (0-1)
 * @param {number} coordinates.x_max - Maximum x coordinate (0-1)
 * @param {number} coordinates.y_max - Maximum y coordinate (0-1)
 * @param {number} imageWidth - Width of the image in pixels
 * @param {number} imageHeight - Height of the image in pixels
 * @returns {Object} Object with pixel coordinates
 */
export function normalizedToPixelCoordinates(coordinates, imageWidth, imageHeight) {
  return {
    x_min: Math.round(coordinates.x_min * imageWidth),
    y_min: Math.round(coordinates.y_min * imageHeight),
    x_max: Math.round(coordinates.x_max * imageWidth),
    y_max: Math.round(coordinates.y_max * imageHeight)
  };
}

================
File: /Users/jess/Desktop/personal git/mobbin/formobbin/lib/services/ai/OpenAIService.js
================
import OpenAI from 'openai';
import { PromptResult } from '../../../types/PromptRunner'; // Adjust the path as needed
import { EXTRACTION_PROMPT_v1, EXTRACT_ELEMENTS_PROMPT,EXTRACTION_PROMPT_v2, EXTRACTION_PROMPT_v3, EXTRACTION_PROMPT_v4 } from '@/lib/prompt/prompts';
import { PromptTrackingContext } from '@/lib/logger';
import { PromptLogType } from '@/lib/constants';
import { cleanText } from '@/lib/file-utils';
// Ensure OPENAI_API_KEY is set in your environment variables
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

// Constants
const OPENAI_CONFIG = {
  VISION_MODEL: 'gpt-4o-2024-11-20',
  VISION_MODEL_GPT4: 'gpt-4.1-2025-04-14',
  INPUT_TOKEN_COST: 0.00001,
  OUTPUT_TOKEN_COST: 0.00003
};

/**
 * Handles the common response processing logic for OpenAI API calls
 */
async function handleOpenAIResponse(response, context, promptType, prompt, startTime) {
  const endTime = Date.now();
  const durationMs = endTime - startTime;

  const inputTokens = response?.usage?.input_tokens || 0;
  const outputTokens = response?.usage?.output_tokens || 0;
  
  await context.logPromptInteraction(
    `OpenAI-${OPENAI_CONFIG.VISION_MODEL_GPT4}`,
    promptType,
    prompt,
    JSON.stringify(response),
    durationMs,
    {
      input: inputTokens,
      output: outputTokens,
      total: response?.usage?.total_tokens
    },
    OPENAI_CONFIG.INPUT_TOKEN_COST,
    OPENAI_CONFIG.OUTPUT_TOKEN_COST
  );

  return response;
}

/**
 * Base function for making OpenAI API calls
 */
async function makeOpenAICall(messages, context, promptType, prompt) {
  const startTime = Date.now();
  
  try {
    const response = await openai.responses.create({
      model: OPENAI_CONFIG.VISION_MODEL_GPT4,
      input: messages
    });
    
    return await handleOpenAIResponse(response, context, promptType, prompt, startTime);
  } catch (error) {
    console.error('Error calling OpenAI Vision Model:', error);
    throw new Error(`Failed to get response from OpenAI: ${error instanceof Error ? error.message : String(error)}`);
  }
}

/**
 * Creates messages payload for OpenAI API
 */
function createMessagesPayload(prompt, image) {
  return [{
    role: 'user',
    content: [
      { type: 'input_text', text: prompt },
      { type: 'input_image', image_url: image }
    ],
  }];
}

/**
 * Calls the OpenAI vision model with a prompt and optional image URL.
 *
 * @param prompt The text prompt to send to the model.
 * @param imageUrl Optional URL of an image for the vision model.
 * @param context The tracking context containing batch, screenshot, and other IDs
 * @param promptType The type of prompt being processed.
 * @returns A promise resolving to the structured PromptResult.
 * @throws Throws an error if the API call fails.
 */
export async function callOpenAIVisionModelURL(
  prompt,
  imageUrl,
  context,
  promptType = PromptLogType.COMPONENT_EXTRACTION
){
  const messages = createMessagesPayload(prompt, imageUrl);
  return makeOpenAICall(messages, context, promptType, prompt);
} 

export async function callOpenAIVisionModelBase64(
  prompt,
  imageBase64,
  context,
  promptType = PromptLogType.ACCURACY_VALIDATION
) {
  const imageUrl = `data:image/jpeg;base64,${imageBase64}`;
  const messages = createMessagesPayload(prompt, imageUrl);
  return makeOpenAICall(messages, context, promptType, prompt);
}

/**
 * Extracts components from an image using the OpenAI vision model.
 *
 * @param imageUrl The URL of the image to analyze.
 * @param context The tracking context containing batch, screenshot, and other IDs
 * @returns A promise resolving to the structured PromptResult.
 * @throws Throws an error if the API call fails.
 */
export async function extract_component_from_image(imageUrl, context) {
  const result = await callOpenAIVisionModelURL(
    EXTRACTION_PROMPT_v4, 
    imageUrl, 
    context,
    PromptLogType.COMPONENT_EXTRACTION
  );
  
  return processResponse(result, `Component extraction failed for URL: ${imageUrl}`);
}

export async function validate_bounding_boxes_base64(imageBase64, context) {
  const result = await callOpenAIVisionModelBase64(
    ACCURACY_VALIDATION_PROMPT_v0, 
    imageBase64, 
    context,
    PromptLogType.ACCURACY_VALIDATION
  );

  return processResponse(result, 'Bounding box validation failed for image');
}

/**
 * Processes OpenAI response data
 */
function processResponse(result, errorMessage) {
  if (!result || result.status !== 'completed') {
    throw new Error(errorMessage);
  }

  const { parsedContent, usage } = extractOpenAIResponseData(result);
  return { parsedContent, usage };
}

/**
 * Helper: Parses OpenAI's output_text string into a JSON object safely.
 *
 * @param rawText - The raw `output_text` returned from OpenAI.
 * @returns Parsed JSON object.
 */
function parseOpenAIOutputTextToJson(rawText) {
  try {
    const cleaned = rawText
    .replace(/,\s*}/g, '}') // remove trailing commas
    .replace(/,\s*]/g, ']') // remove trailing commas
    .trim();

    return JSON.parse(cleaned);

    // const jsonRegex = /```(?:json)?\s*({[\s\S]*?})\s*```|({[\s\S]*})/;
    // const match = rawText.match(jsonRegex);
    
    // const jsonContent = match ? (match[1] || match[2]) : rawText;
    // const cleanedText = cleanText(jsonContent);

    // return JSON.parse(cleanedText);
  } catch (error) {
    console.error('Failed to parse OpenAI output_text as JSON:', error);
    return [];
  }
}


/**
 * Extracts structured content and usage metadata from OpenAI's response.
 *
 * @param response - Full OpenAI response object.
 * @returns Object containing parsed output_text and token usage info.
 */
export function extractOpenAIResponseData(response) {
  const rawText = response?.output_text ?? '';
  const parsedContent = parseOpenAIOutputTextToJson(rawText);

  const usage = {
    input_tokens: response?.usage?.input_tokens,
    output_tokens: response?.usage?.output_tokens,
    total_tokens: response?.usage?.total_tokens
  };

  return {
    parsedContent,
    rawText,
    usage,
  };
}

================
File: /Users/jess/Desktop/personal git/mobbin/formobbin/lib/services/imageServices/BoundingBoxService.js
================
import Jimp from 'jimp';
import fs from 'fs';
import path from 'path';

// --- Constants ---
const BOX_COLOR = 0xFF0000FF; // RGBA Red color
const BOX_WIDTH = 2;
const OVERLAY_COLOR = 0x80808080; // RGBA semi-transparent gray
const OVERLAY_ALPHA = 0.5;
const REFERENCE_POINT_COLOR = 0x00FF00FF; // RGBA Green color
const REFERENCE_POINT_SIZE = 4;
const TEXT_COLOR = 0xFFFFFFFF; // RGBA White color
const TEXT_BACKGROUND = 0x000000AA; // RGBA Black color with some transparency

const SHOW_COORDINATES = process.env.SHOW_COORDINATES === 'true';

/**
 * Normalizes a label string into a file/key-friendly format
 * @param {string} label - The label to normalize
 * @returns {string} Normalized label string
 */
function normalizeLabel(label) {
  return label.toLowerCase().replace(/\s/g, '_').replace(/>/g, '_').replace(/\//g, '_');
}

/**
 * Draw a rectangle with a specific width
 * @param {Jimp} image - Jimp image to draw on
 * @param {number} x - X coordinate of top-left corner
 * @param {number} y - Y coordinate of top-left corner
 * @param {number} width - Width of the rectangle
 * @param {number} height - Height of the rectangle
 * @param {number} color - Color of the rectangle (RGBA hex)
 * @param {number} lineWidth - Width of the rectangle border
 */
function drawRect(image, x, y, width, height, color, lineWidth) {
  // Draw top line
  image.scan(x, y, width, lineWidth, function(cx, cy, idx) {
    this.bitmap.data[idx] = (color >> 24) & 0xFF;     // R
    this.bitmap.data[idx + 1] = (color >> 16) & 0xFF; // G
    this.bitmap.data[idx + 2] = (color >> 8) & 0xFF;  // B
    this.bitmap.data[idx + 3] = color & 0xFF;         // A
  });
  
  // Draw bottom line
  image.scan(x, y + height - lineWidth, width, lineWidth, function(cx, cy, idx) {
    this.bitmap.data[idx] = (color >> 24) & 0xFF;     // R
    this.bitmap.data[idx + 1] = (color >> 16) & 0xFF; // G
    this.bitmap.data[idx + 2] = (color >> 8) & 0xFF;  // B
    this.bitmap.data[idx + 3] = color & 0xFF;         // A
  });
  
  // Draw left line
  image.scan(x, y, lineWidth, height, function(cx, cy, idx) {
    this.bitmap.data[idx] = (color >> 24) & 0xFF;     // R
    this.bitmap.data[idx + 1] = (color >> 16) & 0xFF; // G
    this.bitmap.data[idx + 2] = (color >> 8) & 0xFF;  // B
    this.bitmap.data[idx + 3] = color & 0xFF;         // A
  });
  
  // Draw right line
  image.scan(x + width - lineWidth, y, lineWidth, height, function(cx, cy, idx) {
    this.bitmap.data[idx] = (color >> 24) & 0xFF;     // R
    this.bitmap.data[idx + 1] = (color >> 16) & 0xFF; // G
    this.bitmap.data[idx + 2] = (color >> 8) & 0xFF;  // B
    this.bitmap.data[idx + 3] = color & 0xFF;         // A
  });
}

/**
 * Draw a filled rectangle on the image
 * @param {Jimp} image - Jimp image to draw on
 * @param {number} x - X coordinate of top-left corner
 * @param {number} y - Y coordinate of top-left corner
 * @param {number} width - Width of the rectangle
 * @param {number} height - Height of the rectangle
 * @param {number} color - Color of the rectangle (RGBA hex)
 */
function fillRect(image, x, y, width, height, color) {
  // Make sure coordinates are integers and within bounds
  const startX = Math.max(0, Math.floor(x));
  const startY = Math.max(0, Math.floor(y));
  const imgWidth = image.getWidth();
  const imgHeight = image.getHeight();
  
  // Ensure width/height calculations don't exceed image boundaries
  const endX = Math.min(imgWidth, startX + width);
  const endY = Math.min(imgHeight, startY + height);
  
  const drawWidth = endX - startX;
  const drawHeight = endY - startY;
  
  if (drawWidth <= 0 || drawHeight <= 0) return;
  
  image.scan(startX, startY, drawWidth, drawHeight, function(cx, cy, idx) {
    this.bitmap.data[idx] = (color >> 24) & 0xFF;     // R
    this.bitmap.data[idx + 1] = (color >> 16) & 0xFF; // G
    this.bitmap.data[idx + 2] = (color >> 8) & 0xFF;  // B
    this.bitmap.data[idx + 3] = color & 0xFF;         // A
  });
}

/**
 * Creates a transparent area in the overlay for detected objects
 * @param {Jimp} overlay - Overlay image to modify
 * @param {number} x - X coordinate of top-left corner
 * @param {number} y - Y coordinate of top-left corner
 * @param {number} width - Width of the transparent area
 * @param {number} height - Height of the transparent area
 * @param {number} boxWidth - Width of the border that should remain opaque
 */
function createTransparentArea(overlay, x, y, width, height, boxWidth) {
   // Ensure x, y, width, height are within overlay bounds and integers
   const overlayWidth = overlay.getWidth();
   const overlayHeight = overlay.getHeight();

   const startX = Math.max(0, Math.floor(x + boxWidth));
   const startY = Math.max(0, Math.floor(y + boxWidth));
   const endX = Math.min(overlayWidth, Math.floor(x + width - boxWidth));
   const endY = Math.min(overlayHeight, Math.floor(y + height - boxWidth));

   const clearWidth = Math.max(0, endX - startX);
   const clearHeight = Math.max(0, endY - startY);

   if (clearWidth > 0 && clearHeight > 0) {
       overlay.scan(startX, startY, clearWidth, clearHeight, function(cx, cy, idx) {
           this.bitmap.data[idx + 3] = 0; // Set alpha to 0 (fully transparent)
       });
   }
}

/**
 * Draw a simple coordinate label directly with pixel rectangles
 * @param {Jimp} image - Jimp image to draw on
 * @param {number} x - X coordinate for text start
 * @param {number} y - Y coordinate for text start
 * @param {string} value - Value to display
 * @param {number} color - Text color
 */
function drawCoordinateLabel(image, x, y, value, color = TEXT_COLOR) {
  // First draw background for better visibility
  const padding = 2;
  const charWidth = 5;
  const charHeight = 7;
  const totalWidth = value.length * (charWidth + 1) + padding * 2;
  const totalHeight = charHeight + padding * 2;
  
  // Ensure text stays within image bounds
  const imgWidth = image.getWidth();
  const imgHeight = image.getHeight();
  
  const textX = Math.max(0, Math.min(imgWidth - totalWidth, x));
  const textY = Math.max(0, Math.min(imgHeight - totalHeight, y));
  
  // Draw background
  fillRect(image, textX, textY, totalWidth, totalHeight, TEXT_BACKGROUND);
  
  // Draw text value
  image.scan(textX, textY, totalWidth, totalHeight, function(cx, cy, idx) {
    // Set entire area to the background color with some transparency
    this.bitmap.data[idx + 3] = 180; // Alpha component
  });
  
  // Place coordinate values as plain text using a simple technique
  const text = value;
  let currentX = textX + padding;
  
  for (let i = 0; i < text.length; i++) {
    // Draw a small rectangle for each character with the text color
    // This is a simple way to "stamp" the presence of text without rendering actual fonts
    fillRect(image, currentX, textY + padding, charWidth, charHeight, color);
    currentX += charWidth + 1;
  }
}

/**
 * Draw reference points at 0%, 25%, 50%, 75%, and 100% positions on each edge of the image
 * @param {Jimp} image - Jimp image to draw on
 * @param {number} imgWidth - Width of the image
 * @param {number} imgHeight - Height of the image
 * @param {number} color - Color for reference points (RGBA hex)
 * @param {number} pointSize - Size of the reference points
 */
function drawReferencePoints(image, imgWidth, imgHeight, color = REFERENCE_POINT_COLOR, pointSize = REFERENCE_POINT_SIZE) {
  const percentages = [0, 0.25, 0.5, 0.75, 1.0];
  
  // Top edge points
  percentages.forEach(percent => {
    const x = Math.floor(percent * (imgWidth - 1));
    const y = 0;
    
    // Draw point (larger to be more visible)
    fillRect(image, x - pointSize/2, y - pointSize/2, pointSize, pointSize, color);
    
    // Draw coordinate label
    const labelText = `(${x},${y})`;
    drawCoordinateLabel(image, x - 20, y + pointSize * 2, labelText);
  });
  
  // Bottom edge points
  percentages.forEach(percent => {
    const x = Math.floor(percent * (imgWidth - 1));
    const y = imgHeight - 1;
    
    // Draw point
    fillRect(image, x - pointSize/2, y - pointSize/2, pointSize, pointSize, color);
    
    // Draw coordinate label
    const labelText = `(${x},${y})`;
    drawCoordinateLabel(image, x - 20, y - 20, labelText);
  });
  
  // Left edge points
  percentages.forEach(percent => {
    const x = 0;
    const y = Math.floor(percent * (imgHeight - 1));
    
    // Draw point
    fillRect(image, x - pointSize/2, y - pointSize/2, pointSize, pointSize, color);
    
    // Draw coordinate label
    const labelText = `(${x},${y})`;
    drawCoordinateLabel(image, x + pointSize * 2, y - 10, labelText);
  });
  
  // Right edge points
  percentages.forEach(percent => {
    const x = imgWidth - 1;
    const y = Math.floor(percent * (imgHeight - 1));
    
    // Draw point
    fillRect(image, x - pointSize/2, y - pointSize/2, pointSize, pointSize, color);
    
    // Draw coordinate label
    const labelText = `(${x},${y})`;
    drawCoordinateLabel(image, x - 50, y - 10, labelText);
  });
}

/**
 * Generates an annotated image buffer for a specific component/category
 * @param {Buffer} baseImageBuffer - The original image buffer
 * @param {Array} detectedItems - Detected items for this component
 * @param {number} color - Color for bounding boxes (defaults to BOX_COLOR)
 * @param {string} categoryName - Name of the category (for logging)
 * @returns {Promise<Buffer|null>} Buffer of the annotated image, or null on error
 */
async function generateAnnotatedImageBuffer(baseImageBuffer, detectedItems, color = BOX_COLOR, categoryName) {
  const itemsToDraw = detectedItems.filter(item => item.status === 'Detected' && item.bounding_box);

  try {
    const baseImage = await Jimp.read(baseImageBuffer);
    const imgWidth = baseImage.getWidth();
    const imgHeight = baseImage.getHeight();

    // If there are no items to draw but we need to show coordinates, draw them on the base image
    if (itemsToDraw.length === 0) {
      if (SHOW_COORDINATES) {
        drawReferencePoints(baseImage, imgWidth, imgHeight);
      }
      return await baseImage.getBufferAsync(Jimp.MIME_PNG); // Ensure consistent format
    }

    // Create a semi-transparent overlay
    const overlay = new Jimp(imgWidth, imgHeight, OVERLAY_COLOR);

    // Sort itemsToDraw by area (descending) to process larger boxes first
    // This prevents large-box clear from erasing smaller borders
    itemsToDraw.sort((a, b) => {
      const areaA = (a.bounding_box.x_max - a.bounding_box.x_min) * (a.bounding_box.y_max - a.bounding_box.y_min);
      const areaB = (b.bounding_box.x_max - b.bounding_box.x_min) * (b.bounding_box.y_max - b.bounding_box.y_min);
      return areaB - areaA; // Descending order
    });

    // Process each detection and draw boxes on the overlay
    for (const item of itemsToDraw) {
      const { x_min, y_min, x_max, y_max } = item.bounding_box;

      // Make sure coordinates are integers and within bounds
      const x = Math.max(0, Math.floor(x_min));
      const y = Math.max(0, Math.floor(y_min));
      // Ensure width/height calculations don't exceed image boundaries
      const potentialWidth = Math.ceil(x_max - x_min);
      const potentialHeight = Math.ceil(y_max - y_min);
      const width = Math.min(imgWidth - x, potentialWidth);
      const height = Math.min(imgHeight - y, potentialHeight);

      if (width <= 0 || height <= 0) {
        console.warn(`Invalid box dimensions for item '${item.label}' in category '${categoryName}': ${width}x${height}`);
        continue;
      }

      // Draw the box outline on the overlay
      drawRect(overlay, x, y, width, height, color, BOX_WIDTH);

      // Create transparent area inside the box
      createTransparentArea(overlay, x, y, width, height, BOX_WIDTH);
    }

    // Composite the overlay onto the base image
    baseImage.composite(overlay, 0, 0, {
      mode: Jimp.BLEND_SOURCE_OVER,
      opacitySource: 1, // Use overlay's alpha
      opacityDest: 1
    });

    // Draw reference points if SHOW_COORDINATES is true
    if (SHOW_COORDINATES) {
      drawReferencePoints(baseImage, imgWidth, imgHeight);
    }

    // Return the buffer
    const annotatedBuffer = await baseImage.getBufferAsync(Jimp.MIME_PNG);
    // console.log(`Generated annotated image buffer for category '${categoryName}'.`);
    return annotatedBuffer;

  } catch (err) {
    console.error(`Error generating annotated image buffer for category '${categoryName}': ${err}`);
    return null;
  }
}

/**
 * Renders a category image (for debugging/local saving)
 * @param {Buffer} annotatedImageBuffer - The generated annotated image buffer
 * @param {string} categoryName - Name of the category
 * @param {string} outputDir - Directory to save output
 * @returns {Promise<void>}
 */
async function saveAnnotatedImageDebug(annotatedImageBuffer, categoryName, outputDir) {
   if (!annotatedImageBuffer || process.env.SAVE_DEBUG_FILES !== 'true') {
     return; // Don't save if buffer is null or debug saving is off
   }
   try {
     const normalizedKey = normalizeLabel(categoryName);
     const savePath = path.join(outputDir, `${normalizedKey}.png`);
     await fs.promises.writeFile(savePath, annotatedImageBuffer);
    //  console.log(`Debug image saved successfully to: ${savePath}`);
   } catch (err) {
     console.error(`Error saving debug image for '${categoryName}': ${err}`);
   }
}

export {
  BOX_COLOR,
  BOX_WIDTH,
  OVERLAY_COLOR,
  OVERLAY_ALPHA,
  REFERENCE_POINT_COLOR,
  REFERENCE_POINT_SIZE,
  TEXT_COLOR,
  TEXT_BACKGROUND,
  drawRect,
  fillRect,
  createTransparentArea,
  drawCoordinateLabel,
  drawReferencePoints,
  generateAnnotatedImageBuffer,
  saveAnnotatedImageDebug,
  normalizeLabel
};

================
File: /Users/jess/Desktop/personal git/mobbin/formobbin/lib/services/imageServices/imageFetchingService.ts
================
import { BatchProcessingScreenshot as Screenshot } from '@/types/BatchProcessingScreenshot';
import { Buffer } from 'buffer';

/**
 * Fetches an image and returns it as a Buffer for direct use in image processing.
 * Provides raw binary data with minimal overhead compared to Blob or Base64.
 *
 * @param imageUrl - the signed URL (or any URL) of the image
 * @returns a promise resolving to a Buffer containing the image data
 */
export async function fetchImageAsBuffer(imageUrl: string): Promise<Buffer | null> {
  try {
    const res = await fetch(imageUrl);
    if (!res.ok) throw new Error(`HTTP ${res.status} ${res.statusText}`);
    
    // Get the raw ArrayBuffer first
    const arrayBuffer = await res.arrayBuffer();
    
    // Convert ArrayBuffer to Buffer
    const buffer = Buffer.from(arrayBuffer);
    
    // console.log(`Successfully fetched image buffer (${buffer.byteLength} bytes)`);
    return buffer;
  } catch (err) {
    console.error("Error fetching image as buffer:", err);
    return null;
  }
}

/**
 * Fetches image data as Buffer for multiple screenshots with signed URLs
 * @param screenshots Array of screenshot objects with screenshot_signed_url property
 * @returns The same array with screenshot_image_buffer property populated
 */
export async function fetchScreenshotBuffers(screenshots: Screenshot[]): Promise<Screenshot[]> {
  // console.log(`Fetching image buffers for ${screenshots.length} screenshots...`);
  
  // Create an array of promises for fetching each image
  const fetchPromises = screenshots.map(async (screenshot) => {
    // Skip screenshots without a signed URL
    if (!screenshot.screenshot_signed_url) {
      console.warn(`Screenshot ID ${screenshot.screenshot_id} has no signed URL, skipping buffer fetch`);
      screenshot.screenshot_image_buffer = null;
      return screenshot;
    }
    
    try {
      // Fetch the image buffer and attach it directly
      screenshot.screenshot_image_buffer = await fetchImageAsBuffer(screenshot.screenshot_signed_url);
      
      if (screenshot.screenshot_image_buffer) {
        console.log(`Successfully fetched buffer for screenshot ID ${screenshot.screenshot_id} (${screenshot.screenshot_image_buffer.byteLength} bytes)`);
      }
    } catch (error) {
      console.error(`Error fetching buffer for screenshot ID ${screenshot.screenshot_id}:`, error);
      screenshot.screenshot_image_buffer = null;
    }
    
    return screenshot;
  });
  
  // Wait for all fetch operations to complete
  const updatedScreenshots = await Promise.all(fetchPromises);
  
  // Log summary of results
  const successCount = updatedScreenshots.filter(s => s.screenshot_image_buffer !== null).length;
  // console.log(`Fetched ${successCount}/${screenshots.length} image buffers successfully`);
  
  return updatedScreenshots;
}

================
File: /Users/jess/Desktop/personal git/mobbin/formobbin/lib/services/imageServices/ImageProcessor.ts
================
import sharp from 'sharp'
import fs from 'fs'
import path from 'path'
// import { v4 as uuidv4 } from 'uuid'

// Constants instead of magic numbers
const MAX_FILE_SIZE_MB = 1
const DEFAULT_TARGET_WIDTH = 800
const DEFAULT_TARGET_HEIGHT = 800
const DEFAULT_JPEG_QUALITY = 80

// Temporary directory for processed images
const TEMP_DIR = path.join(process.cwd(), 'tmp')

/**
 * Normalizes a filename by removing special characters and spaces
 * @param filename - Original filename to normalize
 * @returns Normalized filename with only alphanumeric characters, dots, and hyphens
 */
function sanitizeFilename(filename: string): string {
  // Remove file extension
  const { name, ext } = path.parse(filename)
  
  // Replace spaces and special characters with hyphens
  const normalized = name
    .toLowerCase()
    .replace(/[^a-z0-9]/g, '-') // Replace non-alphanumeric with hyphens
    .replace(/-+/g, '-')        // Replace multiple hyphens with single hyphen
    .replace(/^-|-$/g, '')      // Remove leading/trailing hyphens
  
  // Add timestamp to ensure uniqueness
  return `${normalized}${ext}`
}

// Ensure temp directory exists
if (!fs.existsSync(TEMP_DIR)) {
  fs.mkdirSync(TEMP_DIR, { recursive: true })
}

interface ProcessedImage {
  buffer: Buffer;
  filename: string;
}

/**
 * Compresses and pads an image to make it uniform in size
 * @param imageBuffer - The raw image buffer
 * @param originalFilename - Original filename to preserve
 * @param targetWidth - Desired width after processing
 * @param targetHeight - Desired height after processing
 * @returns Object containing the path and filename of the processed image
 */
export async function resizeAndPadImageBuffer(
  imageBuffer: Buffer,
  originalFilename: string,
  targetWidth: number = DEFAULT_TARGET_WIDTH,
  targetHeight: number = DEFAULT_TARGET_HEIGHT
): Promise<ProcessedImage> {
  const filename = sanitizeFilename(originalFilename)
  
  try {
    const metadata = await sharp(imageBuffer).metadata()
    
    // Calculate resize dimensions while maintaining aspect ratio
    let resizeWidth = targetWidth
    let resizeHeight = targetHeight
    
    if (metadata.width && metadata.height) {
      const aspectRatio = metadata.width / metadata.height
      
      if (aspectRatio > 1) {
        // Landscape image
        resizeHeight = Math.round(targetWidth / aspectRatio)
      } else {
        // Portrait image
        resizeWidth = Math.round(targetHeight * aspectRatio)
      }
    }
    
    // Process image and return buffer directly
    const processedBuffer = await sharp(imageBuffer)
      .resize(resizeWidth, resizeHeight, {
        fit: 'inside',
        withoutEnlargement: true
      })
      .jpeg({ quality: DEFAULT_JPEG_QUALITY }) // Compress to reduce file size
      .toBuffer()
      .then(resizedBuffer => {
        // Create a blank canvas with the target dimensions
        return sharp({
          create: {
            width: targetWidth,
            height: targetHeight,
            channels: 4,
            background: { r: 255, g: 255, b: 255, alpha: 1 }
          }
        })
        .composite([{
          input: resizedBuffer,
          gravity: 'center'
        }])
        .jpeg({ quality: DEFAULT_JPEG_QUALITY })
        .toBuffer()
      })

    return {
      buffer: processedBuffer,
      filename
    }
  } catch (error) {
    console.error('Error processing image:', error)
    throw error
  }
}

/**
 * Cleans up a temporary file
 */
export function deleteFile(filePath: string): void {
  try {
    if (fs.existsSync(filePath)) {
      fs.unlinkSync(filePath)
    }
  } catch (error) {
    console.error('Error cleaning up temp file:', error)
  }
}

================
File: /Users/jess/Desktop/personal git/mobbin/formobbin/lib/services/imageServices/screenshotProcessor.ts
================
import { File } from 'formidable';
import fs from 'fs';
import { resizeAndPadImageBuffer, deleteFile } from '@/lib/services/imageServices/ImageProcessor';
import { uploadImageToStorage } from '@/lib/storage';
import { supabase } from '@/lib/supabase'; // Assuming shared Supabase client
import { SupabaseClient } from '@supabase/supabase-js';

interface ProcessedImage {
  processedBlob: Blob;
  filename: string;
  processingTime?: number; // In seconds
}

export class ScreenshotProcessor {
  private supabaseClient: SupabaseClient;

  // Allow injecting Supabase client for testability/flexibility
  constructor(supabaseClient: SupabaseClient = supabase) {
    this.supabaseClient = supabaseClient;
  }

  /**
   * Processes a single uploaded file: resizes, pads, uploads to storage,
   * and saves the record in the database.
   * @param file The uploaded file object from formidable.
   * @param batchId The ID of the batch this screenshot belongs to.
   * @returns The name and URL of the uploaded screenshot.
   * @throws Error if any step fails.
   */
  public async processAndSave(file: File, batchId: number): Promise<{ name: string; url: string }> {
    if (!file || !file.filepath) {
        throw new Error('Invalid file provided to ScreenshotProcessor.');
    }
    
    const processedImage = await this.processUploadedFile(file);
    const savedRecord = await this.saveScreenshotRecord(processedImage, batchId);
    
    // Clean up the temporary file after successful processing and saving
    try {
        deleteFile(file.filepath);
    } catch (cleanupError) {
        // Log cleanup error but don't fail the operation
        console.error(`Failed to delete temporary file ${file.filepath}:`, cleanupError);
    }

    return savedRecord;
  }

  /**
   * Reads, resizes, and pads the image file.
   * @param file The uploaded file object.
   * @returns Processed image data.
   */
  private async processUploadedFile(file: File): Promise<ProcessedImage> {
    const fileBuffer = fs.readFileSync(file.filepath);
    const startTime = Date.now();
    const originalFilename = file.originalFilename ?? `unnamed_${Date.now()}`;

    // Perform image resizing and padding
    const processed = await resizeAndPadImageBuffer(fileBuffer, originalFilename);
    const processingTime = (Date.now() - startTime) / 1000; // Convert ms to seconds

    return {
      processedBlob: new Blob([processed.buffer], { type: 'image/jpeg' }), // Assuming JPEG output
      filename: processed.filename,
      processingTime,
    };
  }

  /**
   * Uploads the processed image to storage and saves the metadata to the database.
   * @param image Processed image data.
   * @param batchId The batch ID.
   * @returns The name and URL of the uploaded screenshot.
   */
  private async saveScreenshotRecord(
    image: ProcessedImage,
    batchId: number
  ): Promise<{ name: string; url: string }> {
    // Upload to Supabase storage
    const { fileUrl, error: uploadError } = await uploadImageToStorage(
      image.processedBlob,
      batchId,
      image.filename
    );
    if (uploadError) {
        console.error('Supabase storage upload error:', uploadError);
        throw new Error(`Failed to upload ${image.filename} to storage.`);
    }

    // Insert record into Supabase database
    const { error: dbError } = await this.supabaseClient
      .from('screenshot')
      .insert({
        batch_id: batchId,
        screenshot_file_name: image.filename,
        screenshot_file_url: fileUrl,
        screenshot_processing_status: 'pending', // Initial status before extraction
        screenshot_processing_time: image.processingTime ? `${image.processingTime.toFixed(2)} seconds` : null,
      });

    if (dbError) {
      console.error('Supabase screenshot insert error:', dbError);
      // Attempt to delete the uploaded file if DB insert fails to avoid orphans
      try {
          // TODO: Implement deletion from storage if needed
          console.warn(`DB insert failed for ${image.filename}, corresponding storage file might be orphaned: ${fileUrl}`);
      } catch (deleteError) {
          console.error(`Failed to delete orphaned storage file ${fileUrl}:`, deleteError);
      }
      throw new Error(`Failed to save screenshot record for ${image.filename}.`);
    }

    return {
      name: image.filename,
      url: fileUrl,
    };
  }
}

================
File: /Users/jess/Desktop/personal git/mobbin/formobbin/lib/services/batchProcessingService.ts
================
import { supabase } from '@/lib/supabase'; 
import { SupabaseClient } from '@supabase/supabase-js';
import { generateSignedUrls, getScreenshotPath, getSignedUrls } from '@/lib/supabaseUtils';
import { fetchScreenshotBuffers } from '@/lib/services/imageServices/imageFetchingService';
import { BatchProcessingScreenshot as Screenshot } from '@/types/BatchProcessingScreenshot';
import type { ComponentDetectionResult } from '@/types/DetectionResult'; 
import pLimit from 'p-limit';
import { AIExtractionService, Stage1Result } from '@/lib/services/ParallelExtractionService';
import { ParallelMoondreamDetectionService } from '@/lib/services/ParallelAnnotationService';
import { EXTRACTION_CONCURRENCY, MOONDREAM_CONCURRENCY, ProcessStatus } from '@/lib/constants';


// --- Constants ---
// const EXTRACTION_CONCURRENCY = 5; // Concurrency limit for OpenAI/Claude calls
// const MOONDREAM_CONCURRENCY = 5; // Limit concurrency for Moondream processing per batch

export class BatchProcessingService {
  private supabaseClient: SupabaseClient;

  // Update constructor to accept StorageService
  constructor(
    supabaseClient: SupabaseClient = supabase,
  ) {
    this.supabaseClient = supabaseClient;
  }

  /**
   * Starts the processing pipeline for a given batch.
   * Changes status, fetches screenshots, gets signed URLs, processes each, and updates status.
   * @param batchId The ID of the batch to process.
   */
  public async start(batchId: number): Promise<void> {
    // console.log(`[Batch ${batchId}] Starting processing...`);
    // const initialStatus = 'processing'; // More generic starting status
    // await this.updateBatchStatus(batchId, initialStatus);

    try {
      // --- Setup 0: Load Screenshots, URLs, Buffers ---
      const screenshotsToProcess = await this.loadAndPrepareScreenshots(batchId);
      if (!screenshotsToProcess || screenshotsToProcess.length === 0) {
        return; // Early return handled in the helper function with appropriate status updates
      }

      // --- Stage 1: Parallel AI Component/Element/Anchor Extraction ---
      await this.updateBatchStatus(batchId, ProcessStatus.EXTRACTING);
      console.log(`[Batch ${batchId}] Begin Parallel Extraction on ${screenshotsToProcess.length} screenshots`);
      
      // Use the external AIExtractionService
      const stage1Results = await AIExtractionService.performAIExtraction(batchId, screenshotsToProcess);
      
      // Filter out screenshots that failed Stage 1 before proceeding to Stage 2
      const successfulScreenshotIds = new Set(
          Array.from(stage1Results.entries())
              .filter(([_, result]) => !result.error) // Keep only entries without an error
              .map(([id, _]) => id) // Get the screenshot IDs
      );

      const screenshotsForMoondream = screenshotsToProcess.filter(s =>
          successfulScreenshotIds.has(s.screenshot_id)
      );

      if (screenshotsForMoondream.length === 0) {
          console.warn(`[Batch ${batchId}] No screenshots successfully completed Stage 1. Cannot proceed to Moondream.`);
          // Consider the final status - potentially 'failed' or a specific 'extraction_failed' status
          await this.updateBatchStatus(batchId, ProcessStatus.FAILED);
          return;
      }
      console.log(`[Batch ${batchId}] ${screenshotsForMoondream.length} screenshots proceeding to Stage 2 (Moondream).`);

      // --- Stage 2: Parallel Moondream Detection ---
      await this.updateBatchStatus(batchId, ProcessStatus.ANNOTATING); 
      // console.log(`[Batch ${batchId}] Starting Moondream detection for ${screenshotsForMoondream.length} screenshots with concurrency ${MOONDREAM_CONCURRENCY}...`);
      
      // Use the external ParallelMoondreamDetectionService
      const allDetectionResults = await ParallelMoondreamDetectionService.performMoondreamDetection(
        batchId, 
        screenshotsForMoondream, 
        stage1Results
      );
      
      // --- Stage 3: Persist Results ---
      await this.updateBatchStatus(batchId, ProcessStatus.DONE);
      console.log(`[Batch ${batchId}] Placeholder: Persisting ${allDetectionResults.length} component results...`);
      // TODO: Implement persistence logic for `allDetectionResults`
      // 1. Upload unique annotated_image_objects to Storage
      // 2. Get public URLs
      // 3. Update ComponentDetectionResult objects
      // 4. Save component_detection metadata
      // 5. Save element_detection items


      // --- Finalize ---
      await this.updateBatchStatus(batchId, ProcessStatus.DONE); // Update status to 'done' after successful processing
      console.log(`[Batch ${batchId}] Processing complete. Status set to done.`);

    } catch (error) {
      // Catch errors from setup phase or unhandled exceptions in stages
      await this.handleProcessingError(batchId, error);
    }
  }

  /**
   * Loads screenshots, processes signed URLs, and fetches screenshot buffers
   * @param batchId The ID of the batch to process
   * @returns Array of screenshots ready for processing with buffers and signed URLs
   */
  private async loadAndPrepareScreenshots(batchId: number): Promise<Screenshot[]> {
    // Load screenshots from database
    const screenshots = await this.loadScreenshots(batchId);
    if (screenshots.length === 0) {
      console.log(`[Batch ${batchId}] No screenshots found. Setting status to done.`);
      await this.updateBatchStatus(batchId, ProcessStatus.DONE);
      return [];
    }
    console.log(`[Batch ${batchId}] Found ${screenshots.length} screenshots.`);

    // Process signed URLs
    await this.processSignedUrls(batchId, screenshots);
    // console.log(`[Batch ${batchId}] Processed signed URLs.`);

    // Fetch screenshot buffers
    await this.fetchScreenshotBuffers(screenshots);
    // console.log(`[Batch ${batchId}] Fetched screenshot buffers.`);

    // Filter screenshots that have both buffer and signed URL for processing
    const screenshotsToProcess = screenshots.filter(
      s => s.screenshot_image_buffer && s.screenshot_signed_url
    );

    if (screenshotsToProcess.length === 0) {
      console.warn(`[Batch ${batchId}] No screenshots with image buffers and signed URLs found after fetching. Cannot proceed.`);
      // Decide status: 'failed' if buffers were expected, 'done' if URLs weren't generated?
      await this.updateBatchStatus(batchId, ProcessStatus.FAILED);
      return [];
    }
    // console.log(`[Batch ${batchId}] ${screenshotsToProcess.length} screenshots eligible for processing.`);
    
    return screenshotsToProcess;
  }

  private async loadScreenshots(batchId: number): Promise<Screenshot[]> {
    const screenshots = await this.getBatchScreenshots(batchId);
    return screenshots;
  }

  private async processSignedUrls(batchId: number, screenshots: Screenshot[]): Promise<void> {
    // 1. Derive bucket paths
    const filePaths = screenshots
      .map(s => getScreenshotPath(s.screenshot_file_url))
      .filter((p): p is string => p !== null); // Type guard to filter nulls and ensure string[]

    if (filePaths.length !== screenshots.length) {
      console.warn(
        `[Batch ${batchId}] ${screenshots.length - filePaths.length} invalid screenshot file URLs found. Associated screenshots skipped for URL generation.`
      );
      // Optionally filter the screenshots array itself here if needed later
    }
    if (filePaths.length === 0) {
      console.log(`[Batch ${batchId}] No valid file paths found. Skipping signed URL fetch.`);
      // Update screenshots array to empty or mark them as missing URL?
      screenshots.forEach(s => {
          s.screenshot_signed_url = undefined;
          s.screenshot_bucket_path = undefined;
      });
      return;
    }

    // 2. Fetch signed URLs
    let signedUrls = new Map<string, string>();
    try {
      signedUrls = await getSignedUrls(this.supabaseClient, filePaths);
    } catch (urlError) {
      console.error(`[Batch ${batchId}] Failed to get signed URLs:`, urlError);
      // Consider how to handle this - fail the batch or proceed without URLs?
      // For now, proceed but log the issue. Screenshots without URLs will be filtered out later.
    }

    // 3. Attach to screenshots
    let attachedCount = 0;
    screenshots.forEach(s => {
      const path = getScreenshotPath(s.screenshot_file_url);
      if (path && signedUrls.has(path)) {
        s.screenshot_signed_url = signedUrls.get(path)!;
        s.screenshot_bucket_path = path;
        attachedCount++;
      } else {
        // Ensure screenshots that didn't get a URL (due to invalid path or fetch error) have undefined values
        s.screenshot_signed_url = undefined;
        s.screenshot_bucket_path = undefined;
      }
    });
    // console.log(`[Batch ${batchId}] Attached signed URLs to ${attachedCount} out of ${screenshots.length} initial screenshots (${filePaths.length} valid paths attempted).`);
  }


  private async handleProcessingError(batchId: number, error: unknown): Promise<void> {
    console.error(`[Batch ${batchId}] Critical error during batch processing:`, error);
    try {
      await this.updateBatchStatus(batchId, ProcessStatus.FAILED);
      console.error(`[Batch ${batchId}] Status set to failed.`);
    } catch (statusError) {
      console.error(
        `[Batch ${batchId}] Failed to update status to failed after critical error:`,
        statusError
      );
    }
  }


  /**
   * Updates the status of a batch in the database.
   * @param batchId The ID of the batch.
   * @param status The new status string.
   */
  private async updateBatchStatus(batchId: number, status: string): Promise<void> {
    const { error } = await this.supabaseClient
      .from('batch')
      .update({ batch_status: status, updated_at: new Date().toISOString() }) // Add updated_at
      .eq('batch_id', batchId);

    if (error) {
      console.error(`[Batch ${batchId}] Supabase batch status update error to '${status}':`, error);
      // Avoid throwing here to allow subsequent error handling like handleProcessingError to proceed
      // throw new Error(`Failed to update batch ${batchId} status to ${status}.`);
    } else {
      console.log(`[Batch ${batchId}] Status updated to '${status}'.`);
    }
  }



  /**
   * Fetches all screenshot records for a given batch ID.
   * @param batchId The ID of the batch.
   * @returns An array of screenshot records.
   */
   // Update return type to use the Screenshot interface
  private async getBatchScreenshots(batchId: number): Promise<Screenshot[]> {
    const { data, error } = await this.supabaseClient
      .from('screenshot')
      .select('*')
      .eq('batch_id', batchId);

    if (error) {
      console.error(`[Batch ${batchId}] Supabase screenshot fetch error:`, error);
      // Rethrow or return empty? Returning empty allows process to potentially continue if error is transient, but might hide issues.
      // Let's return empty and log, the calling function handles the empty case.
      return [];
    }

    // Explicitly cast data to Screenshot[] after checking for null/undefined
    return (data as Screenshot[] | null) || [];
  }


  /**
   * Fetches image data as ArrayBuffer for each screenshot with a valid signed URL
   * @param screenshots Array of screenshot objects with screenshot_signed_url property
   * @returns The same array of screenshots with screenshot_image_buffer property populated
   */
  public async fetchScreenshotBuffers(
    screenshots: Screenshot[]
  ): Promise<Screenshot[]> {
    // Assuming fetchScreenshotBuffers handles its own logging and concurrency
    return fetchScreenshotBuffers(screenshots);
  }
}

================
File: /Users/jess/Desktop/personal git/mobbin/formobbin/lib/services/DatabaseService.ts
================
import { createClient, SupabaseClient } from '@supabase/supabase-js';
import { SUPABASE_URL, SUPABASE_KEY } from '../../config'; // Adjust path as needed

export class DatabaseService {
  private static instance: DatabaseService;
  private client: SupabaseClient;

  private constructor() {
    if (!SUPABASE_URL || !SUPABASE_KEY) {
      throw new Error('Supabase URL or Key is missing in config.ts');
    }
    // Use Database type if you have generated types, otherwise use 'any'
    this.client = createClient<any>(SUPABASE_URL, SUPABASE_KEY);
  }

  public static getInstance(): DatabaseService {
    if (!DatabaseService.instance) {
      DatabaseService.instance = new DatabaseService();
    }
    return DatabaseService.instance;
  }

  public getClient(): SupabaseClient {
    return this.client;
  }
}

================
File: /Users/jess/Desktop/personal git/mobbin/formobbin/lib/services/ParallelAnnotationService.ts
================
import { BatchProcessingScreenshot as Screenshot } from '@/types/BatchProcessingScreenshot';
import type { ComponentDetectionResult } from '@/types/DetectionResult';
import { Stage1Result } from '@/lib/services/ParallelExtractionService';
// Import from the correct module
import { processAndSaveByCategory } from '@/lib/services/ai/MoondreamDetectionService';
import pLimit from 'p-limit';
import { MOONDREAM_CONCURRENCY } from '@/lib/constants';
import { createScreenshotTrackingContext } from '@/lib/logger';

 
/**
 * ParallelMoondreamDetectionService
 * 
 * This service handles the parallel processing of screenshots through Moondream's
 * language vision models, using anchor labels from previous AI processing steps
 * to guide object detection within UI screenshots.
 * 
 * DESIGN DECISIONS:
 * 1. Controlled Parallelism: We implement managed concurrency to balance throughput 
 *    against system resource constraints. This approach prevents overwhelming the 
 *    local model while still achieving significant performance gains.
 * 
 * 2. Error Isolation: Each screenshot is processed independently in its own promise,
 *    allowing failures to be contained without affecting the entire batch.
 * 
 * 3. Result Aggregation: All detection results are collected into a flat array,
 *    making it easier to persist results as a single operation rather than per-screenshot.
 * 
 * 4. Contextual Processing: By utilizing the anchor labels from Stage 1, we provide
 *    semantic context to the vision model, improving its accuracy in identifying
 *    specific UI components.
 * 
 * 5. Comprehensive Error Handling: We use Promise.allSettled to ensure the pipeline 
 *    continues even when individual screenshots fail processing.
 */
export class ParallelMoondreamDetectionService {
  /**
   * Performs parallel Moondream detection on screenshots using anchors from Stage 1
   * 
   * TECHNICAL DETAILS:
   * - Implements a processing pool with p-limit to manage resource consumption
   * - Each screenshot is processed independently within the concurrency pool
   * - Results are flat-mapped into a single array for efficient bulk persistence
   * - Empty arrays are returned for failed screenshots to maintain processing flow
   * - Promise.allSettled ensures batch resilience against individual failures
   * 
   * @param batchId The ID of the batch being processed (for logging)
   * @param screenshots Array of screenshots that passed Stage 1
   * @param stage1Results Map of Stage 1 results by screenshot ID
   * @returns Array of ComponentDetectionResult objects
   */
  public static async performMoondreamDetection(
    batchId: number, 
    screenshots: Screenshot[], 
    stage1Results: Map<number, Stage1Result>
  ): Promise<ComponentDetectionResult[]> {

    // Create concurrency limiter for Moondream to prevent resource exhaustion
    // This is especially important as Moondream is compute-intensive
    const moondreamLimit = pLimit(MOONDREAM_CONCURRENCY);
    const allDetectionResults: ComponentDetectionResult[] = []; // Collect all results in flat array
    
    console.log(`[Batch ${batchId}] Stage 2: Starting Bounding Box Detection for ${screenshots.length} screenshots... Concurrency: ${MOONDREAM_CONCURRENCY}`);

    // Initialize parallel detection tasks with controlled concurrency
    const detectionPromises = screenshots.map(screenshot =>
      moondreamLimit(async () => {
        // const context = createScreenshotTrackingContext(batchId, screenshot.screenshot_id);
        const screenshotId = screenshot.screenshot_id;
        // We know buffer exists because it passed the initial filter
        const buffer = screenshot.screenshot_image_buffer!;
        // We know stage 1 results exist because we filtered for successful ones
        const stage1Data = stage1Results.get(screenshotId)!;
        const anchorLabels = stage1Data.anchorLabels;

        console.log(`[Batch ${batchId}] Stage 2: Moondream labelling screenshot ${screenshotId}...`);

        try {
          // Process screenshot with Moondream using component anchors
          // These anchors provide semantic context to improve detection accuracy
          const results: ComponentDetectionResult[] = await processAndSaveByCategory(
            screenshotId,
            buffer,
            anchorLabels, // Use the labels derived specific to this screenshot
            batchId
          );
          console.log(`[Batch ${batchId}] Stage 2: Finished Moondream labelling for screenshot ${screenshotId}. Results count: ${results.length}`);
          return results; // Return results for this screenshot
        } catch (error) {
          // Log error but continue processing other screenshots
          console.error(`[Batch ${batchId}] Stage 2: Error labelling screenshot ${screenshotId} with Moondream:`, error);
          return []; // Return empty array on error for this screenshot
        }
      })
    );

    // Wait for all detection tasks to complete or fail
    // Using Promise.allSettled ensures we collect all successful results
    // even if some screenshots fail processing
    const settledMoondreamResults = await Promise.allSettled(detectionPromises);
    
    // Aggregate results from all successfully processed screenshots
    settledMoondreamResults.forEach(result => {
      if (result.status === 'fulfilled' && Array.isArray(result.value)) {
        // Spread array results into the flat collection
        allDetectionResults.push(...result.value);
      } else if (result.status === 'rejected') {
        // Error already logged inside the promise, add batch-level context
        console.error(`[Batch ${batchId}] Stage 2: A Moondream detection task failed:`, result.reason);
      }
    });
    
    return allDetectionResults;
  }
}

================
File: /Users/jess/Desktop/personal git/mobbin/formobbin/lib/services/ParallelExtractionService.ts
================
import { BatchProcessingScreenshot as Screenshot } from '@/types/BatchProcessingScreenshot';
import { extract_component_from_image } from '@/lib/services/ai/OpenAIService';
import { extract_element_from_image, anchor_elements_from_image } from '@/lib/services/ai/ClaudeAIService';
import pLimit from 'p-limit';
import { EXTRACTION_CONCURRENCY } from '@/lib/constants';
import { createScreenshotTrackingContext, PromptTrackingContext } from '@/lib/logger';

// --- Types for intermediate results ---
export interface Stage1Result {
    componentSummaries: string[];
    elementResultRawText: string;
    anchorLabels: Record<string, string>;
    error?: any; // error tracking per screenshot
}

/**
 * AIExtractionService
 * 
 * This service handles the parallel extraction of components, elements, and anchors from screenshots
 * using multiple AI systems (OpenAI and Claude).
 * 
 * DESIGN DECISIONS:
 * 1. Parallel Processing: We use controlled parallelism to maximize throughput without overwhelming 
 *    external API services. This balances speed with reliability and cost management.
 * 
 * 2. Fault Tolerance: Each screenshot is processed independently, and errors are captured per 
 *    screenshot rather than failing the entire batch. This allows partial batch success.
 * 
 * 3. Progressive Enhancement: The extraction pipeline builds incrementally, with each step using 
 *    the results of the previous step:
 *    - Component extraction identifies high-level UI patterns
 *    - Element extraction uses components to find specific elements
 *    - Anchor labeling uses element data to establish reference points
 * 
 * 4. Data Integrity: Results include error tracking to allow downstream processes to filter out
 *    failed operations and proceed with successful ones.
 */
export class AIExtractionService {
  /**
   * Extracts components, elements, and anchors from screenshots in parallel
   * 
   * TECHNICAL DETAILS:
   * - Implements controlled parallelism with p-limit to manage API rate limits
   * - Each screenshot processing runs independently with Promise.allSettled for fault isolation
   * - Maps screenshot IDs to their extraction results for later processing stages
   * - Progressive extraction: Components → Elements → Anchors
   * - Comprehensive error capture to prevent batch failure from individual items
   * 
   * @param batchId The ID of the batch being processed (for logging)
   * @param screenshots Array of screenshots with buffers and signed URLs
   * @returns Map of screenshot IDs to Stage1Result objects
   */
  public static async performAIExtraction(batchId: number, screenshots: Screenshot[]): Promise<Map<number, Stage1Result>> {
    // Create a concurrency limiter to prevent overwhelming external AI services
    // This is crucial for rate limit management and cost control
    const extractionLimit = pLimit(EXTRACTION_CONCURRENCY);
    const stage1Results = new Map<number, Stage1Result>(); // Map screenshot_id to results

    // Map each screenshot to a promise that processes it within concurrency limits
    const extractionPromises = screenshots.map(screenshot =>
      extractionLimit(async () => {
        const screenshotId = screenshot.screenshot_id;
        const signedUrl = screenshot.screenshot_signed_url!; // We filtered for this previously
        console.log(`[Batch ${batchId}] Stage 1: Processing screenshot ${screenshotId}...`);

        // Create a tracking context for this screenshot
        const context = createScreenshotTrackingContext(batchId, screenshotId);

        try {
          // 1. Extract Components using OpenAI vision capabilities
          // Components represent high-level UI patterns (forms, cards, etc.)
          console.log(`[Batch ${batchId}][Screenshot ${screenshotId}] Step 1.1 : Extracting High-Level Components...`);
          const componentResult = await extract_component_from_image(signedUrl, context);
          const componentSummaries = this.extractComponentSummaries(componentResult.parsedContent || []);
          console.log(`[Batch ${batchId}][Screenshot ${screenshotId}] Step 1.1 Complete. Found ${componentSummaries.length} Main Components.`);

          // 2. Extract Elements based on Components using Claude
          // Elements are specific interactive parts informed by component context
          console.log(`[Batch ${batchId}][Screenshot ${screenshotId}] Step 1.2 : Extracting Detailed Elements...`);
          const elementResult = await extract_element_from_image(signedUrl, componentSummaries.join('\n'), context);
          console.log(`[Batch ${batchId}][Screenshot ${screenshotId}] Step 1.2 Complete. Found ${elementResult.parsedContent.length} Detailed Elements.`);

          // 3. Anchor Elements based on Element Extraction
          // Anchors provide spatial reference points for Moondream to use later
          console.log(`[Batch ${batchId}][Screenshot ${screenshotId}] Step 1.3 : Optimising descriptions for VLM detection`);
          const anchorResult = await anchor_elements_from_image(signedUrl, `${elementResult.rawText}`, context);
          const anchorLabels: Record<string, string> = anchorResult.parsedContent || {};
          console.log(`[Batch ${batchId}][Screenshot ${screenshotId}] Step 1.3 Complete. Optimised ${Object.keys(anchorLabels).length} labels.`);

          if (Object.keys(anchorLabels).length === 0) {
            console.warn(`[Batch ${batchId}][Screenshot ${screenshotId}] No anchor labels generated. Moondream detection might be ineffective.`);
          }

          // Store successful results
          stage1Results.set(screenshotId, {
            componentSummaries,
            elementResultRawText: elementResult.rawText || '',
            anchorLabels,
          });
          console.log(`[Batch ${batchId}][Screenshot ${screenshotId}]Successfully processed screenshot ${screenshotId}. Found ${componentSummaries.length} Main Components, ${elementResult.parsedContent.length} Detailed Elements, ${Object.keys(anchorLabels).length} Optimised Labels.`);

        } catch (error) {
          console.error(`[Batch ${batchId}][Screenshot ${screenshotId}] Step 1.4 : Error processing screenshot ${screenshotId}:`, error);
          // Store error information for reporting and later filtering
          // This resilience allows the process to continue with successfully processed screenshots
          stage1Results.set(screenshotId, {
            componentSummaries: [],
            elementResultRawText: '',
            anchorLabels: {},
            error: error, // Store the error for filtering and diagnosis
          });
        }
      })
    );

    // Wait for all extractions to complete (successfully or with errors)
    // We use Promise.allSettled instead of Promise.all to prevent a single failure from stopping the batch
    await Promise.allSettled(extractionPromises);
    console.log(`[Batch ${batchId}] Completed Stage 1 AI extraction for all applicable screenshots.`);
    
    return stage1Results;
  }

  /**
   * Helper function to extract component summaries from AI extraction results
   * This is to pass to the element extraction step
   * 
   * @param components Array of components from AI extraction
   * @returns Array of component summary strings (just names for now)
   */
  private static extractComponentSummaries(components: any[]): string[] {
    if (!Array.isArray(components)) {
      console.warn("ExtractComponentSummaries: Expected an array of components, received:", typeof components);
      return [];
    }

    return components
      // Ensure component is an object and has the required string properties
      .filter(component =>
          typeof component === 'object' &&
          component !== null &&
          typeof component.component_name === 'string' &&
          typeof component.description === 'string' // Keep description check even if not used in output
      )
      .map(component => component.component_name); // Just using name now
  }
}

================
File: /Users/jess/Desktop/personal git/mobbin/formobbin/lib/services/sample_vision_api_call.txt
================
import OpenAI from "openai";

const openai = new OpenAI();

const response = await openai.responses.create({
    model: "gpt-4o-2024-11-20",
    input: [{
        role: "user",
        content: [
            { type: "input_text", text: "what's in this image?" },
            {
                type: "input_image",
                image_url: "https://upload.wikimedia.org/wikipedia/commons/thumb/d/dd/Gfp-wisconsin-madison-the-nature-boardwalk.jpg/2560px-Gfp-wisconsin-madison-the-nature-boardwalk.jpg",
            },
        ],
    }],
});

console.log(response.output_text);



import Anthropic from '@anthropic-ai/sdk';

const anthropic = new Anthropic({
  apiKey: process.env.ANTHROPIC_API_KEY,
});

async function main() {
  const message = await anthropic.messages.create({
    model: "claude-3-7-sonnet-20250219",
    max_tokens: 1024,
    messages: [
      {
        role: "user",
        content: [
          {
            type: "image",
            source: {
              type: "url",
              url: "https://upload.wikimedia.org/wikipedia/commons/a/a7/Camponotus_flavomarginatus_ant.jpg"
            }
          },
          {
            type: "text",
            text: "Describe this image."
          }
        ]
      }
    ]
  });
  
  console.log(message);
}

main();

================
File: /Users/jess/Desktop/personal git/mobbin/formobbin/types/BatchProcessingScreenshot.ts
================
import { Buffer } from 'buffer';

export interface BatchProcessingScreenshot {
    screenshot_id: number;
    batch_id: number;
    screenshot_file_name: string;
    screenshot_file_url: string; // URL like https://<...>/public/<bucket>/<path>
    screenshot_processing_status: string;
    screenshot_processing_time: string;
    screenshot_created_at: string;
    screenshot_signed_url?: string | null;
    screenshot_bucket_path?: string | null;
    // screenshot_image_blob?: Blob | null;
    // screenshot_image_base64?: string | null; // Base64 encoded image with data URI prefix
    screenshot_image_buffer?: Buffer | null; // Raw buffer data for image processing
  }

================
File: /Users/jess/Desktop/personal git/mobbin/formobbin/types/DetectionResult.ts
================
interface ElementDetectionItem {
  label: string;
  description: string;
  bounding_box: {
    x_min: number;
    y_min: number;
    x_max: number;
    y_max: number;
  };
  status: 'Detected' | 'Not Detected' | 'Error';
  vlm_model: string; // Track which model provided the detection
  element_inference_time: number; // Time taken for this specific element
  accuracy_score?: number; // Optional: To be added later
  suggested_coordinates?: { x_min: number; y_min: number; x_max: number; y_max: number }; // Optional: To be added later
}

interface ComponentDetectionResult {
  screenshot_id: number;
  component_name: string; // Top-level category/component name
  annotated_image_object: Buffer; // The rendered image buffer for this component
  annotated_image_url?: string; // To be populated after upload
  component_description: string; // Maybe derived from element descriptions or passed in
  detection_status: 'success' | 'partial' | 'failed'; // Overall status for this component
  inference_time: number; // Total time for this component's elements
  elements: ElementDetectionItem[];
}

// Export the interfaces
export type { ComponentDetectionResult, ElementDetectionItem };
